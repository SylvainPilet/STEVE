{InstallPkg: func(newPkg, prompt)beginPrint('InstallPkg);	local pkgName := BinaryMunger(	// from Q&A. see PkgInfo		Clone(""), 0, 0,		newPkg,		52 + (ExtractLong(newPkg,48)*32) + ExtractWord(newPkg,24),		ExtractWord(newPkg, 26) - 2);Print(pkgName);	local newPkgVersion := ExtractLong(newPkg, 16);Print(newPkgVersion);	local newPkgDate := 0, i;	for i := 32 to 35 	/* (Mac) date has seconds */	do newPkgDate := (newPkgDate*256) + (ExtractByte(newPkg,i) / 60);	newPkgDate := Floor(newPkgDate);Print(DateNTime(newPkgDate));	local oldPkg, store, oldPkgRef, oldPkgVersion, oldPkgDate;	foreach store in GetStores()			// was GetPackageStores	do if oldPkg := GetPkgRef(pkgName, store)		then begin			oldPkgRef := GetPkgRefInfo(oldPkg); // easier than extracting			oldPkgVersion := oldPkgRef.version;Print(oldPkgVersion);			oldPkgDate := oldPkgRef.creationDate;Print(DateNTime(oldPkgDate));			break;			end;	if prompt	then AsyncConfirm(		(if oldPkg then "Replace:" else "Install:") && pkgName & unicodeCR &		(if oldPkg then "old version:" && oldPkgVersion & ", created:" && DateNTime(oldPkgDate) & unicodeCR) &		"new version:" && newPkgVersion & ", created:" && DateNTime(newPkgDate),		'yesNo,		func(x)		if x		then :InstallPkg2(oldPkg, newPkg, Intern(pkgName))		else Print("user refused")		)	else if not oldPkg or (newPkgVersion >= oldPkgVersion and newPkgDate > oldPkgDate)	then :InstallPkg2(oldPkg, newPkg, Intern(pkgName))	else Print("not newer");end,InstallPkg2: func(oldPkg, newPkg, pkgSym)beginPrint('InstallPkg2);	local blessed := oldPkg and GetUserConfig('blessedApp) = pkgSym;Print(blessed);	if blessed	then GetRoot():BlessApp('ExtrasDrawer)	/* close current, open a built-in one */	else GetRoot().(pkgSym):?close();Print('close);	AddDelayedSend(self, 'InstallPkg3, [oldPkg, newPkg, pkgSym, blessed], 5000);end,InstallPkg3: func(oldPkg, newPkg, pkgSym, blessed)try beginPrint('InstallPkg3);	if oldPkg	then SafeRemovePackage(oldPkg);Print('SuckPackagefromBinary);	GetDefaultStore():SuckPackagefromBinary(newPkg,		{callbackFreq: 10000,	// callbackFrequency wrong in docs!		callBack: func(callbackInfo) NIL,	//callbackInfo.amountRead, callbackInfo.packageSize		});Print(blessed);	if blessed	then GetRoot():BlessApp(pkgSym);Print('done);	endonexception |evt.ex|do Print(currentException()),}:installPkg(rpkg, true)-------constant kWordSize := 65536;constant kByteSize := 256;constant kVBOFlush := 24*1024;rpkg := {nextFlush:	kVBOFlush,kExtractNum3: // extract 3 digit number (inline for speed?)	func NATIVE (pkg, INT offset)	ExtractByte(pkg, offset) 	* kWordSize +	ExtractByte(pkg, offset+1) 	* kByteSize +	ExtractByte(pkg, offset+2),reloFix: 	func NATIVE (pkg, copyOk)begin	local INT numParts 	:= ExtractWord(pkg, 50); 	// assume # parts < 65536(kWordSize)	local INT flagByte1 := ExtractByte(pkg, 12);	local okrelo :=		Band(flagByte1, 0x04) = 0					// relocation header flag off?		and (copyOk or Band(flagByte1, 0x40) = 0);	// copy protected flag off?	local i, s;	for i:=0 to 7	do s := s & Chr(ExtractByte(pkg,i));	Print("format:" && s);	// usually(only?): package0 or package1	Print("numParts:" && numParts);	if Band(flagByte1, 0x40)<>0 then Print("COPY PROTECTED!");	if Band(flagByte1, 0x04)<>0 then Print("RELOCATION INFO!");	local INT offset, partNum, partIndex, obj, partOffset := ExtractWord(pkg, 46);	local ARRAY relo := Array(4, NIL);	if okrelo	then begin // copy, setup		gc();		pkg := BinaryMunger(			GetDefaultStore():NewCompressedVBO('package, Length(pkg), kTextCompander,nil),0,nil,			pkg,0,nil);		ClearVBOCache(pkg);	// do this now		end;	for partNum := 0 to numParts-1	do begin		partIndex := 52 + (partNum * 32);	// each part header is 32 bytes long		// first object of each part is an array with 1 element (a part frame)		offset := partOffset + :kExtractNum3 (pkg, partIndex+1);Print("part:" && partNum);Print("offset:" && offset);Print("part length:" &&			// uncompressed? size: 8-11	:kExtractNum3  (pkg, partIndex+9)); Print("part type:" &&			// type: 12-15 (assumes null term in 16!)	ExtractCString(pkg, partIndex+12)); Print("part kind:" &&			// flags: 20-23'["protocol", "frames", "raw", "??"][BAND(ExtractByte(pkg,partIndex+23),0x3)]);		if partNum=0 and okrelo		then begin			// skip header,0,type(+12)			// assume [0] points to next object (+4) in pkg			// keep relo in array of 4 bytes -- "long" is too big; (words messy)			// this appears to be constant throughout entire normal package			obj := offset+16;			relo[0] := ExtractByte(pkg,offset+12);			relo[1] := ExtractByte(pkg,offset+13) - (obj div kWordSize);			obj := obj mod kWordSize;			relo[2] := ExtractByte(pkg,offset+14) - (obj div kByteSize);			relo[3] := ExtractByte(pkg,offset+15) - (obj mod kByteSize) - 1;  // for obj ptr//if kDebugOn then begin Write("relo: "); Print(relo); end;			end;		if okrelo		then :reloFixObj(pkg, offset, relo);		end;	if okrelo	then begin		ClearVBOCache(pkg);	// one last time		pkg;		end;	//else NILend,ReloFixObj:func NATIVE (pkg, INT offset, ARRAY relo)begin // fix objects within a part	// DATA (0x40), ARRAY (0x41), FRAME (0x43)	local INT ctype := ExtractByte(pkg,offset+3);	local INT clen :=		if ctype = 0x40 // DATA		then 12 // only check type		else :kExtractNum3 (pkg, offset);	local INT i, p, obj;	for i := offset+8 to offset+clen-4 by 4	do	if ExtractByte(pkg,i) <> 0  				// not already relocated? (assumes pkg < 17M)	  		and BAND(ExtractByte(pkg, i+3), 0x3) = 1	// obj ptr?	  	then begin			obj := 0;			for p := 0 to 3			do obj := obj*kByteSize + ExtractByte(pkg,i+p) - relo[p];//if kDebugOn then Print(i & $: && obj);			StuffLong(pkg, i, obj);			if i > nextFlush			then begin				ClearVBOCache(pkg);				nextFlush := nextFlush + kVBOFlush;				end;			obj := obj-1; 		// make ptr an offset			// any "normal" package appears to first save a (forward) pointer to an object			// and later the object itself; other references to obj might be back (ok).			// if there is a package that doesn't re-upload properly			// you could comment out the following test, though since it would (re)check			// validity of every pointer in an array or frame, it could slow things down					if obj > offset		// needs fixing only if later in package? assumes first ref is forward			then :reloFixObj(pkg, obj, relo);			end;end,}:reloFix(Clone(GetPkgRef("Doggie:LeeMoon", GetStores()[1]), nil)