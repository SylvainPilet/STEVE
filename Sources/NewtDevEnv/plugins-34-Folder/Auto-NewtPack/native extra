stuffVPUM	local int segBeg, segSz := segSize;	local immedVal := call Functions.IsImmediate with (val);	if immedVal and isInstance(val,'int) and val > 0x17FFFFFF // isInstance breaks if array class is a number	then begin		segBeg := segBegin;		if (segOffset := offset - segBeg) >= segSz			or offset < segBeg		then :setOffset(offset,TRUE);		:stuffNum(segment, segOffset, val, 4, -2) // "big" INT	end	else begin		local int sval :=			if val=kSymbolType 	// my special symbol flag			then 0x00055552			else if immedVal or call Functions.IsMagicPtr with(val)				// IMMEDIATE ("small" INT, NIL, TRUE, WEAK ARRAY, UNICODE CHAR) or MAGIC POINTER			then REFOF(val)			else // POINTER: FRAME, ARRAY, SYMBOL, BINARY				:stuffChunk(nextChunk,val)+1;		segBeg := segBegin;		if (segOffset := offset - segBeg) >= segSz			or offset < segBeg		then :setOffset(offset,TRUE);		StuffLong(segment, segOffset, sval);		end;-------stuffChunkfunc (int offset,obj)begin	local SymP := Functions.SymbolP;	local ArrayP := Functions.IsArray, SlotP := Functions.HasSlot;	if call ArrayP with(obj) and ClassOf(obj)='deferredPackageObject	then obj := if call SymP with(obj[0])		then call Functions.Perform with (evalView,obj[0],obj[1])		else call obj[0] with(obj[1]);	local pos; // was getObjOffset	if call ArrayP with(obj) and Classof(obj)='_pkgOffset_ // see shareObj	then return obj[0]	else if pos := ArrayPos(pkgObjs,obj,0,nil)	then return pkgOffs[pos];	local int origOffset := offset, ctype, apos, len;	local val, slot, arg, sym;	local array aarg;if not kReleasethen begin write(offset&": "); Print(obj); end;// INIT HEADER INFO	if call Functions.isFrame with(obj) 		// FRAME	then begin		if call SlotP with (obj,'_MyParent_)		then begin			call Functions.RemoveSlot with (obj,'_MyParent_);			call Functions.RemoveSlot with (obj,'_parent);			end;		ctype := 0x43;		len := Length(obj);		aarg := arg := call Functions.Array with(len+1,NIL); // frame map		apos := 0;		local sortArg := len>20 and not call SlotP with (obj,'_nextArgFrame);		foreach slot,val in obj		do aarg[apos:=apos+1] :=				if slot and sortArg				then call kSymHash with (nil,0,nil,slot)				else slot;		slot := if call SlotP with (obj,'_proto)			then 4			else if len=0 // _nextArgFrame, _parent, _implementor, other???				or call SlotP with (obj,'viewClass) // kludge-orama ???				or firstFrame // 1st framemap ***				// generally, top level of the pkg frame except theForm?				or (len=3 and Length(call Functions.SetDifference with('[mask,bits,bounds],arg))=0) // this ok since sortArg nil				then 0			else 2;		firstFrame := NIL;		if sortArg		then beginif not kRelease then Print(arg);			Sort(aarg, kSymCompare, nil);			for apos:=1 to len // fixup (skip 0=nil)			do aarg[apos] := aarg[apos][3];if not kRelease then Print(arg);			slot := slot+1;			end;		SetClass(arg,slot);		len := 4 * (3+len); // frame entry lenif not kRelease then Print(arg);		end	else if call ArrayP with (obj)	// ARRAY	then begin		ctype := 0x41;		len := 4 * (3 + Length(obj));		arg := if origOffset<>firstChunk then ClassOf(obj); // else NIL (for very first array)		aarg := obj;		end	else begin 				// SYMBOL, DATA		ctype := 0x40;		if call SymP with (obj)		then beginif not kRelease then Print(obj);			arg := kSymbolType;			sym := val := call Functions.SPrintObject with(obj);			len := 17 + call Functions.StrLen with(val); // + hash(4), null(1)			end		else begin			arg := ClassOf(obj);			len := 12 + Length(obj);			end;		end;	//local currentPath := progress.currentPath.text;Progress:update(offset, nil, true);// WRITE CHUNK HEADER INFO	if (segOffset := offset - segBegin) >= segSize		or offset < segBegin	then :setOffset(offset,TRUE);	// update offset ptr for nextChunk, rounded up to 8-byte boundary	nextChunk := nextChunk + ((len+7) div 8) * 8;	:stuffNum(segment, segOffset, len, 3, 0);	StuffByte(segment, segOffset+3, ctype);	StuffLong(segment, segOffset+4, 0);	:stuffVPUM(offset:=offset+8, arg);// WRITE OBJECT	if ctype = 0x40			// DATA	then if arg=kSymbolType		then begin			offset := offset+4;			if (segOffset := offset - segBegin) >= segSize				or offset < segBegin			then :setOffset(offset,TRUE);			call kSymHash with (segment, segOffset, val, nil);			:StuffCString2(offset+4, val, 0, -1);			end		else :StuffBytes2(offset+4, obj, 0, -1)	else if ctype = 0x41	// ARRAY	then for apos:=0 to Length(aarg)-1 // aarg=obj		do :stuffVPUM(offset := offset+4, aarg[apos]);	else // else if ctype = 0x43 then // FRAME		for apos:=0 to Length(aarg)-1		//foreach slot in arg // since framemap may have been sorted!		do if (slot := aarg[apos]) // skip initial NIL			then begin				if not ArrayPos('[						class, literals, argFrame, instructions, numArgs,						_nextArgFrame, _parent, _implementor, preAllocatedContext],					slot,0,nil)				then SetValue(progress.currentPath, 'text, SPrintObject(slot));				:stuffVPUM(offset:=offset+4, obj.(slot));				end;//	:shareObj(obj,origOffset,TRUE);	if call SymP with (obj)		or call Functions.IsReadOnly with (obj)		or (call ArrayP with (obj) and isInstance(Classof(obj),'int))	then begin		AddArraySlot(pkgOffs, origOffset);		AddArraySlot(pkgObjs, obj);		end	else ReplaceObject(obj, [_pkgOffset_: origOffset]);	origOffset;end