// Text of project NewtPack1x.¹ written on 12/31/95 at 8:34 AM// Beginning of text file Project Data// NewtPack (Newt Packages) (autopart) 3.2// Copyright 1995-96 S. Weyer. All Rights Reserved Worldwideconstant kNewtPack := "NewtPack";constant kVersionNum 	:= "3.2";constant kBetaVersion 	:= "";constant kBuild20 := NIL;DefConst('kVersionString,	kVersionNum & kBetaVersion &	(if kDebugOn then "D") &	(if kProfileOn then "P") &	(if not kIgnoreNativeKeyword then "N"));DefConst('kVersion, kNewtPack && kVersionString);Print(kVersion);constant kCopyright   := "© 1995-96,"; // used also for dev copyrightconstant kCopyAuthor  := "S. Weyer (portions may be derived from Newtonª Toolkit © 1992-95, Apple Computer, Inc.)";DefConst('kCopyTool, kVersion && kCopyright && kCopyAuthor);constant kNewtSymbol  := '|NewtDevEnv:TKnollSys|;constant kPkgSoupName := "TEMPPKG:TKnollSys";constant kSegSize		 := 4096;constant kPlugType	 := 'protos;constant pkgSym 		 := 'protoPackage;constant progSym 		 := 'protoProgress;constant kTooBig		 := "pkgOffset too big";constant kFakeParent  := '_MyParent_;InstallScript := func(partFrame,removeFrame) // #1begin	local gData := GetGlobals().(kNewtSymbol);	if not gData	then GetGlobals().(EnsureInternal(kNewtSymbol)) :=		gData := EnsureInternal(			{constants: {}, libraries: {}, protos: {}, tools: {}, views: {}, });	gData.(kPlugType).(EnsureInternal(pkgSym)) := partFrame.partData.(pkgSym);	gData.(kPlugType).(EnsureInternal(progSym)) := partFrame.partData.(progSym);end;RemoveScript := func(removeFrame) // #2begin	local protos := GetGlobals().(kNewtSymbol).(kPlugType);	RemoveSlot(protos, pkgSym);	RemoveSlot(protos, progSym);end;partData := {}; // set protoPackage, protoProgress in afterScriptconstant kSymbolType := '|?$_Symbol_$?|;constant eArray := '[];DefConst('eFrame, {});DefConst('kArrayEqual, func(array a1, array a2) // #3if isArray(a2) //and isArray(a1)	and length(a1)=length(a2)	and classof(a1)=classof(a2)then begin	local int i;	for i:=0 to length(a1)-1	do if a1[i] <> a2[i] then return NIL;	return TRUE;	end);DefConst('orda, ord($a));DefConst('ordz, ord($z));DefConst('kSymCompare, func native (h1, h2) // [hi,lo,str,sym]  // #5if h1=NIL then -1else if h2=NIL then 1else begin	local array a1 := h1, a2 := h2;	local int hi := a1[0]-a2[0], lo;	if hi=0	then if (lo := a1[1]-a2[1])=0		then call Functions.StrCompare with(a1[2],a2[2])		else lo	else hi;	end);DefConst('kFindArray, func native (array objs, array aobj) // #6begin	local int i, j, alen := Length(aobj);	local aclass := ClassOf(aobj), found;	local array obj1;	local kIsArray := Functions.IsArray;	for i:=0 to Length(objs)-1	do begin		obj1 := objs[i];		if alen = Length(obj1) and aclass = ClassOf(obj1)		then for j:=0 to (found := alen-1)			do if obj1[j]<>aobj[j] then break found := NIL;		if found then return i;		end;end);DefConst('kMarkObject, func(objects,offsets,obj,offset,add,pos)if addthen begin	AddArraySlot(objects, obj);	AddArraySlot(offsets, offset);	Length(offsets)-1; // for later remove	endelse begin	if pos	then begin		ArrayRemoveCount(objects,pos,1);		ArrayRemoveCount(offsets,pos,1);		end;//Print([offset,obj]);	ReplaceObject(obj, [_pkgOffset_: offset]);	end);DefConst('kSymHash, func native (data, int offset, str, sym)begin	if not str	then str := call Functions.SPrintObject with(sym);	local int i, ch, tot:=0;	local OrdFn := Functions.Ord;	for i:=0 to call Functions.StrLen with(str)-1	do begin		ch := call OrdFn with(str[i]);		tot := tot + if orda<=ch and ch<=ordz then ch-32 else ch;		end;	local int lo := 0x79B9 * tot;	local int hi := (0x9E37 * tot) + (lo >> 16);	if data	then begin		StuffWord(data, offset,   hi);		StuffWord(data, offset+2, lo);		end	else begin // assume array		local array dd := call Functions.Array with(if sym then 4 else 2, NIL);		dd[offset]   := Band(hi,0xFFFF);		dd[offset+1] := Band(lo,0xFFFF);		if sym		then begin // for sorting			dd[offset+2] := str;			dd[offset+3] := sym;			end;		dd;		end;end);DefConst('kFormInstallScript, func(partFrame) // InstallScript for a normal (part) packagebegin//Print("installing" && partFrame.app);	if Extras exists and ArrayPos(Extras,partFrame.app,0,func(a,e) a=e.app)	then GetRoot():Notify(3,		EnsureInternal("Extras Drawer"),		"Duplicate App" && partFrame.app)	else if HasSlot(partFrame,'devInstallScript)	then begin		partFrame:devInstallScript(partFrame);		partFrame.devInstallScript := NIL;		end;	partFrame.InstallScript := NIL;//Print("end install");end);DefConst('kFormRemoveScript, func(partFrame) partFrame:?devRemoveScript(partFrame));DefConst('kAutoInstallScript, func(partFrame)begin	local rFrame := EnsureInternal({removeScript: partFrame.devRemoveScript});	partFrame:devInstallScript(partFrame, rFrame);	rFrame;end);DefConst('kDeletionScript, func() nil);// End of text file Project Data// Beginning of file EmptyLayout_view000 :=    {viewBounds: {left: 40, top: 16, right: 152, bottom: 72},     viewFlags: 1,     viewFormat: nil,     viewClass: 74    };constant |layout_EmptyLayout| := _view000;// End of file EmptyLayout// Beginning of file protoProgressprotoProgress :=    {viewBounds: {left: 6, top: 160, right: -6, bottom: 210},     Update:       func(val) //,pathstr,refr)       begin       	//self:open();       	SetValue(currentSize,'text, NumberStr(val));       	SetValue(progressGauge, 'viewValue, max(min(val,maxProgressValue),0));              /*	local elapsed := if startTime       		then TimeInSeconds() - startTime       		else begin       			startTime := TimeInSeconds();       			0;       			end;       	local secs := elapsed mod 60;       	SetValue(elapsedTime, 'text,       		(elapsed div 60) & (if secs < 10 then ":0" else ":") & secs);       */              	//if pathstr then SetValue(currentPath,'text, pathstr); // or set separately       	//if refr then       	RefreshViews();       end,     maxProgressValue: nil,     progressLabel: "",     startTime: nil,     viewSetupDoneScript:       func()       begin       	closebox:hide();       	AddDeferredAction(func(view)       		if Visible(view) then view.closebox:show(),       		[self]);       end,     ReorientToScreen:       @588 //ROM_DefRotateFunc       ,     viewJustify: 48,     _proto: @179    };label :=    {text: "",     viewBounds: {top: 3, left: 1, right: -1, bottom: 15},     viewJustify: 8388656,     viewSetupFormScript:       func()       begin       	text := progressLabel;       	inherited:?viewSetupFormScript();       end,     _proto: @218    };AddStepForm(protoProgress, label);progressGauge :=    {viewBounds: {top: 18, left: 1, right: -1, bottom: 33},     viewSetupFormScript:       func()       begin       	maxValue := maxProgressValue;       	minValue := viewValue := 0;       end,     viewValue: 50,     viewJustify: 48,     _proto: @182    };AddStepForm(protoProgress, progressGauge);StepDeclare(protoProgress, progressGauge, 'progressGauge);currentPath :=    {text: "",     viewBounds: {top: -14, left: 1, right: -85, bottom: -2},     viewJustify: 8388784,     _proto: @218    };AddStepForm(protoProgress, currentPath);StepDeclare(protoProgress, currentPath, 'currentPath);currentSize :=    {text: "0",     viewBounds: {top: -14, left: -80, right: -20, bottom: -2},     viewJustify: 8388769,     _proto: @218    };AddStepForm(protoProgress, currentSize);StepDeclare(protoProgress, currentSize, 'currentSize);closebox := {_proto: @166};AddStepForm(protoProgress, closebox);StepDeclare(protoProgress, closebox, 'closebox);// After Script for "protoProgress"thisView := protoProgress;partData.(progSym) := thisViewconstant |layout_protoProgress| := protoProgress;// End of file protoProgress// Beginning of file protoPackageprotoPackage :=    {     printHexBin:       func(data, offset, len, hub)       begin       	// print Hex, Unicode or Binary format       	local s := if hub='h then "0x" else if hub='u then "\u" else "";       	local digits :=       		if hub='b       		then [       			"0000", //0       			"0001", //1       			"0010", //2       			"0011", //3       			"0100", //4       			"0101", //5       			"0110", //6       			"0111", //7       			"1000", //8       			"1001", //9       			"1010", //A       			"1011", //B       			"1100", //C       			"1101", //D       			"1110", //E       			"1111", //F       			]       		else "0123456789ABCDEF";              	local num := if isBinary(data) then NIL else data;       	local i, lim := len*8 - 4;       	for i:=0 to lim by 4       	do s := s & digits[       		Band(if num       				then num >> (lim-i)       				else ExtractByte(data, offset + (i div 8)) >> ((i+4) mod 8),       			0xF)];       	s;       end,     FrameDiff:       func(f1,f2,diff)       if length(f1)=length(f2)       then begin       	local slot,val;       	local slots1 := foreach slot,val in f1 collect slot;       	local slots2 := foreach slot,val in f2 collect slot;       	if (val := if classof(slots1) <> classof(slots2) then 'class)       		or val := :ArrayDiff(slots1,slots2,[])       	then return SetAdd(diff,['map, val],nil);              	foreach slot in slots1       	do if :ObjDiff(f1,f2,slot,diff)       		then return SetAdd(diff,slot,nil);       	//NIL;       	end       else SetAdd(diff,'len,nil),     ObjDiff:       func(obj1,obj2,path,diff)       begin       	local v1 := obj1, v2 := obj2;       	if path //and length(path)>0       	then begin       		v1 := obj1.(path);       		v2 := obj2.(path);       		end;              	if v1=v2 then return NIL;              	if classof(v1)<>classof(v2)       		or isImmediate(v1) or isImmediate(v2)       		or length(v1)<>length(v2)       	then return diff;              	if isInstance(v1,'string) // IsString(v1)       	then if StrEqual(v1,v2) // make case sensitive?? **       		then NIL       		else diff       	else if isFrame(v1)       	then :FrameDiff(v1,v2,diff)              	else if isArray(v1)       	then :ArrayDiff(v1,v2,diff)              	else if isBinary(v1)       	then :BinDiff(v1,v2,diff)              	else :Notify(3, "unrecognized type for", [v1,v2]);       end,     segOffset: nil,     setOffset:       func native (int pkgOffset, alloc)       if cursor       then begin       	local int segNum := pkgOffset div kSegSize;       	local int segLen := Length(segments), i, segBeg;       	segBegin := segBeg := segNum * kSegSize;       	segOffset := pkgOffset - segBeg;       	local array segs := segments;       	if alloc and segEntry       	then call Functions.EntryChange with(segEntry);       	if segNum < segLen       	then begin       		segment := segEntry := NIL;       		segEntry := cursor:GoToKey(segs[segNum]);       		segment := segEntry.packageEntry;       		end       	else if alloc       	then for i:=segLen to segNum       		do begin       if kDebugOn then Print("seg" & i);       			segment := segEntry := NIL;       			segment := SetLength(clone("\u"), kSegSize);       			SetClass(segment, 'packageEntry);       			segEntry := cursor.soup:Add({packageEntry: segment});       			AddArraySlot(segs, call Functions.EntryUniqueId with(segEntry));       			segment;       			end       	else GetRoot():Notify(kNotifyAlert,       			EnsureInternal(kTooBig), SPrintObject(pkgOffset));       	end       else // small package       	if alloc       then if segment       	then SetLength(segment, segSize := ((pkgOffset div kSegSize)+1) * kSegSize) // pkgOffset=segOffset       	else begin // 1st time       		segment := SetLength(clone("\u"), kSegSize);       		SetClass(segment, 'packageEntry);       		segBegin := 0;       		segOffset := pkgOffset;       		end       else GetRoot():Notify(kNotifyAlert,       			EnsureInternal(kTooBig), SPrintObject(pkgOffset)),     extractChunk:       func(offset)       begin       	local obj, origOffset := offset, pos := SetContains(pkgOffs,offset);       	if pos       	then return pkgObjs[pos];       		/* begin       		obj := pkgObjs[pos];       		if isArray(obj) and isInstance(classof(obj),'int)       		then begin write("shared framemap "); print(obj); end;       		return obj; //pkgObjs[pos];       		end; */              progress:update(offset); //,nil,true);              	if (segOffset := offset - segBegin) >= segSize       		or offset < segBegin       	then :setOffset(offset,NIL);       	local ctype := ExtractByte(segment, segOffset+3);       	local len := :extractNum(segment, segOffset, 3, 0);       	local arg := :extractVPUM(offset:=offset+8), val;              	if ctype = 0x40			// DATA       	then //:extractData(offset, len, arg)       		begin       			obj := if arg=kSymbolType       				then begin       						if (segOffset := offset+4 - segBegin) >= segSize       							or offset < segBegin       						then :setOffset(offset+4,NIL);       					local shash := [:extractNum(segment,segOffset,  2,0),       										 :extractNum(segment,segOffset+2,2,0)];       						//ExtractBytes(segment, segOffset+4, 4,'String);       					val := :ExtractCString2(offset+8, len-16);              					local hilo := call kSymHash with(nil,0,val,nil);       					if call kArrayEqual with (shash, hilo)       					then Print(val)       					else Print(["*****", val, shash, hilo]);              					Intern(val);       					end       				else if keepValue then :ExtractBytes2(offset+4, len-12, arg);       //Print(if arg='symbol or arg='string then obj else "<"&arg&":"&(len-12)&">");              			:shareObj(obj,origOffset);       			obj;       		end              	else if ctype = 0x41	// ARRAY       	then //:extractArray(offset, clen, arg)       		begin       //if not IsInstance(arg,'symbol) then print(:printhexbin(segment,segOffset,4,'H)); // type as binary       			local i, alen := (len div 4) - 3;       //Print("["&alen&"]");       			if arg='Array and alen=0       			then eArray       			else begin       				obj := Array(alen,nil);       				if arg       				then SetClass(obj,arg);       				:shareObj(obj,origOffset);       				for i:= 0 to alen-1       				do obj[i] := :extractVPUM(offset:=offset+4);       //if isInstance(arg,'int) then begin write(arg&""); Print(obj); end;       				obj;       				end;       		end              	else //if ctype = 0x43 then // FRAME       		//:extractFrame(offset, clen, arg)       		begin       Print(arg);       		if length(arg)=0       		then eFrame       		else begin       			local slot, slot2;       			obj := {};       			:shareObj(obj,origOffset);       			foreach slot in arg       			do if isArray(slot)       			then begin       Print("??? nested frame map at" && origOffset); // assume no more than 1 level of nesting ***       				foreach slot2 in slot       				do if slot2       				then begin       					val := :extractVPUM(offset:=offset+4);       					if keepValue then obj.(slot2) := val;       					end;       				end       			else if slot       			then begin       					val := :extractVPUM(offset:=offset+4);       					if keepValue then obj.(slot) := val;       					end;       			obj;       			end;       		end;       	/* else 					// ERROR       		:Notify(3,"unrecognized chunk",ctype);*/       end,     stuffPartHeader:       func(offset,devCopyright,packageName,partSym)       begin       	StuffLong	(segment, offset+ 0, 0); 	// ***       	//StuffLong	(segment, offset+ 4, 0); // length(part) -- see stuffPackage              	//StuffLong	(segment, offset+ 8, 0); // ditto          StuffCString(segment, offset+12, partSym); // form, book, auto, ***              	StuffLong	(segment, offset+16, 0);       	StuffLong	(segment, offset+20, 0x00000081);              	local strOff := 32;       	local len := length(devCopyright); // \u       	BinaryMunger(segment, offset+strOff, len, devCopyright, 0, len);       	strOff := strOff+len;              	len := length(packageName); // \u       	BinaryMunger(segment, offset+strOff, len, packageName, 0, len);       	strOff := strOff+len;              	len := StrLen(partSym); // -null              	// now fill these in       	StuffWord	(segment, offset+24, strOff-32);       	StuffWord	(segment, offset+26, len);       	StuffLong	(segment, offset+28, 0);              	StuffCString(segment,offset+strOff,partSym); // form, auto, etc.       	strOff := strOff+len;              	len := StrLen(kCopyTool)+1; // +null       	StuffCString	(segment,offset+strOff,kCopyTool);              	nextChunk := ((offset+strOff+len+pkgGrid-1) div pkgGrid) * pkgGrid; // round to next 8-byte boundary       end,     nextChunk: nil,     segment: nil,     extractPackage:       func()       begin       	:setOffset(0,NIL);       	local pkgFrame := {};       	local offset := :printPkgEntries(       		segment,0, "PACKAGE HEADER", pkgFrame,'[       		[char, verify_text,		//   0 'package0' - lets us know this is a package!       			8, "package0"],	       		[char, unknown_text,		//   8 'xxxx' or ' no ' or 'none' - unknown usage       			4, "xxxx",],       		[long, package_flags],	//  12 a combination of the PF_ flags #define'd above       		[long, pkg_version],		//  16 version # of package from NTK dialog       		[int,  zeroPad, nil, 0],//  20 0       		[int,  dcopyright_len],	//  22 length of devel copyright text       		[int,  dcopyright_len2,	//  24 (repeated)       			nil, dcopyright_len],       		[int,  packname_len],	//  26 length of name of package       		[long, package_len],		//  28 length of entire package       		[long, create_time],		//  32 [Mac] creation time/date of package (secs since 1/1/04)       		[time, modif_time],		//  36 [Newton] modification time       		[long, zeroPad, nil, 0],//  40 0       		[long, hdr_length],		//  44 length of package header       		[long, num_parts,			//  48 number of parts in the package       			nil, 1],       		]);              	pkgFrame.real_part_len := pkgFrame.package_len - pkgFrame.hdr_length;              // assume 1 part ***       	offset := :printPkgEntries(       		segment,offset, "PART HEADER", pkgFrame, '[       			[long, part_offset,	//  52 offset of start of part data (within the package)       				nil, 0],	       			[long, part_length,	//  56 length of part       				nil, real_part_len],		       			[long, part_length2,	//  60 length of part       				nil, part_length],       			[char, part_type, 4,	//  64 'form', 'book', 'auto', etc.       				"form"],       			[long, zeroPad,		//  68 0       				nil, 0],       			[long, val81, nil,	//  72 0x00000081       					0x00000081],       			[int,  part_sym_off],//  76 offset from start of text section of the "part symbol"       			[int,  part_sym_len,	//  78 length of "part symbol"       				nil, 4],       			[long, zeroPad,		//  80 0       				nil, 0],       			]);              	offset := :printPkgEntries(       		segment,offset, "STRING SECTION", pkgFrame, '[       			[uchar,dev_copyright,       			   dcopyright_len],	//  84 copyright string from NTK project window.  Null terminated.       			[uchar,packname,       			   packname_len],		// name of package as seen in "Remove Software"       			[char, part_symbol,       			   part_sym_len, part_type],	// 'form' or 'Monaco' or freeform text - seemingly not used.       			[char,NTK_copyright],// 'Newtonª Toolkit Package © 1992-1994, Apple Computer, Inc.'       			]);              	local hlen := pkgFrame.hdr_length;       	pkgFrame := {}; // recycle       	pkgFrame.part1 := :extractChunk(hlen);       	pkgFrame;       end,     extractString:       func(data, offset, len, cl, step) // used only by printPkgEntry       begin       	// return string or unicode string,       	// either with length specified or null terminated       	// for step=1, len=nil  -- use ExtractCString       	// for step=2, len<>nil -- use ExtractBytes       	local i := offset, ch, null:=chr(0), s := "";       	local offlen := if len then offset+len;       	while not offlen or i < offlen       	do begin       		ch := if step=1       			then ExtractChar(data, i);       			else ExtractUniChar(data, i);       		if ch=null then break;               s := s&ch;               i := i+step;       		end;       	s;       end,     firstChunk: nil,     stuffChunk:       func (INT offset, obj)       begin       	local pos, cl := if isFrame(obj) then 'frame else ClassOf(obj);       	local origObj := obj; // esp. for deferredPackageObject       	if cl='symbol // IsSymbol(obj)       	then (if pos := GetSlot(pkgObjF, obj) then return pos)       	else begin       		if //isArray(obj) and       			cl='deferredPackageObject       		then begin       			local fn := obj[0], args := obj[1];       			if not isArray(args) then args := [args];       			obj := if isInstance(fn,'symbol)       				then Perform(evalView,fn,args)       				else Apply(fn,args);       			end;              		if isArray(obj)       		then begin       			cl := ClassOf(obj);       			if cl = '_pkgOffset_ // see shareObj       			then return obj[0];       			if isinstance(cl,'int)       			then (if pos := call kFindArray with (pkgAObjs,obj) // frame maps       					then return pkgAOffs[pos])       			else pos := SetContains(pkgObjs,obj); // array (probably readonly)       			end       		else pos := SetContains(pkgObjs,obj); // other (readonly) obj       		if pos       		then return pkgOffs[pos];       		cl := if isFrame(obj) then 'frame else ClassOf(obj);       		end;              	local int origOffset := offset, ctype, len;       	local val, slot, arg, sym, ro := isReadonly(obj);              if kDebugOn       then begin write(offset&": "); Print(obj); end;              // INIT HEADER INFO       	if isFrame(obj) 		// FRAME       	then begin       		if HasSlot(obj,kFakeParent)       		then begin       			RemoveSlot(obj,kFakeParent);       			RemoveSlot(obj,'_parent);       			end;              		ctype := 0x43;       		len := Length(obj);       		arg := Array(len+1,NIL); // frame map       		pos := 0;       		local sortArg := len>20 and not HasSlot(obj,'_nextArgFrame);       		foreach slot,val in obj       		do arg[pos:=pos+1] :=       				if slot and sortArg       				then call ksymHash with(nil,0,nil,slot)       				else slot;              		slot := if HasSlot(obj,'_proto)       			then 4       			else if len=0 // _nextArgFrame, _parent, _implementor, other???       				or HasSlot(obj,'viewClass) // kludge-orama ???       				or firstFrame // 1st framemap ***       				// generally, top level of the pkg frame except theForm?       				or (len=3 and Length(SetDifference('[mask,bits,bounds],arg))=0) // this ok since sortArg nil       				then 0       			else 2;       		firstFrame := NIL;              		if sortArg       		then begin       if kDebugOn then Print(arg);       			Sort(arg, kSymCompare, nil);       			for pos:=1 to len // fixup (skip 0=nil)       			do arg[pos] := arg[pos][3];       if kDebugOn then Print(arg);       			slot := slot+1;       			end;              		SetClass(arg,slot);       		len := 4 * (3+len); // frame entry len       if kDebugOn then Print(arg);       		end              	else if isArray(obj)	// ARRAY       	then begin       		ctype := 0x41;       		len := 4 * (3 + Length(obj));       		arg := if origOffset<>firstChunk then cl; // else NIL (for very first array)       		end              	else begin 				// SYMBOL, DATA       		ctype := 0x40;       		if isInstance(obj,'symbol) // isInstance(obj)       		then begin       if kDebugOn then Print(obj);       			arg := kSymbolType;       			sym := val := SPrintObject(obj);       			len := 17 + StrLen(val); // + hash(4), null(1)       			end       		else begin       			arg := cl;       			len := 12 + Length(obj);       			end;       		end;              	//local currentPath := progress.currentPath.text;       if ctype<>0x40 then Progress:update(offset); //, nil, true);              // WRITE CHUNK HEADER INFO       	// update offset ptr for nextChunk, rounded up to "8-byte" boundary       	nextChunk := nextChunk + ((len+pkgGrid-1) div pkgGrid) * pkgGrid;              	:stuffNum(offset, len, 3, 0); // sets segOffset       	StuffByte(segment, segOffset+3, ctype);              	offset := offset+4;       	if (segOffset := offset - segBegin) >= segSize       		or offset < segBegin       	then :setOffset(offset,TRUE);       	StuffLong(segment, segOffset, 0);              	:stuffVPUM(offset:=offset+4, arg);              // WRITE OBJECT       	if ctype = 0x40			// DATA       	then if arg=kSymbolType       		then begin       			offset := offset+4;       			if (segOffset := offset - segBegin) >= segSize       				or offset < segBegin       			then :setOffset(offset,TRUE);       			call ksymHash with (segment, segOffset, val, nil);       			:StuffCString2(offset+4, val, 0, -1);       			pkgObjF.(obj) := origOffset; // save offset       			end       		else begin       			:StuffBytes2(offset+4, obj, 0, -1);       			call kMarkObject with (pkgObjs, pkgOffs, origObj, origOffset, ro, nil); // save offset       			end              	else if ctype = 0x41	// ARRAY       	then begin       		if isInstance(cl,'int) // framemap       		then begin       			AddArraySlot(pkgAOffs, origOffset);       			AddArraySlot(pkgAObjs, obj);       			ro := true; // no need to remove/re-add from other list       			end       		else pos := call kMarkObject with (pkgObjs, pkgOffs, origObj, origOffset, true, nil); // (temporarily) save offset       		foreach val in obj       		do :stuffVPUM(offset := offset+4, val);       		if not ro       		then call kMarkObject with (pkgObjs, pkgOffs, origObj, origOffset, nil, pos);       		end              	else begin // else if ctype = 0x43 then // FRAME       		pos := call kMarkObject with (pkgObjs, pkgOffs, origObj, origOffset, true, nil); // (temporarily) save offset       		foreach slot in arg // since framemap may have been sorted!       		do if slot // skip initial NIL       			then begin       				if not SetContains('[       						class, literals, argFrame, instructions, numArgs,       						_nextArgFrame, _parent, _implementor, preAllocatedContext],       					slot)       				then SetValue(progress.currentPath, 'text, SPrintObject(slot));       				:stuffVPUM(offset:=offset+4, GetSlot(obj,slot));       				end;       		if not ro       		then call kMarkObject with (pkgObjs, pkgOffs, origObj, origOffset, nil, pos);       		end;              	origOffset;       end,     segEntry: nil,     pkgObjF: nil,     pkgObjs:       nil // array of some (e.g., symbol) package objects (corresponds to pkgOffs)       ,     pkgOffs:       nil // array of some (e.g., symbol) package offsets       ,     GetDefaultStore:       if kBuild20 then kGetDefaultStoreDeprecatedFunc else kGetDefaultStoreFunc     ,     savePackage:       func(fl)       if fl       then begin       	local newtPkg := appTemplate._package;       	local asym := appTemplate.appSymbol;       	if newtPkg.existingPackage       	then :?RemovePackage(asym);       	:?removeApp(newtPkg.newtSymbol);	// since this is destructive       	RemoveSlot(appTemplate,'_package); // don't save this              	local pkgFrame, partData := newtpkg.partData, isbn := appTemplate.isbn;       	local devInstallScript := newtpkg.installScript;       	local devRemoveScript := newtpkg.removeScript;              	local version := if isbn then appTemplate.version else newtpkg.version;       	local copyright := if isbn then appTemplate.copyright else newtpkg.copyright;              	if partData       	then pkgFrame := {       			devInstallScript: devInstallScript,       			devRemoveScript: 	devRemoveScript,       			InstallScript:		kAutoInstallScript,       			partData: 			partData,       			}       	else if isbn       	then pkgFrame := {book: appTemplate}       	else begin       		local stitle := newtpkg.shortTitle;       		local icon := newtpkg.icon;       		local autoClose := newtpkg.autoClose;       		pkgFrame := {       			app: asym,       			text: if stitle then stitle else appTemplate.title,       			icon: if icon then icon else genericAppIcon,       			theForm: appTemplate,       			InstallScript: kFormInstallScript,       			RemoveScript:  kFormRemoveScript,       			};       		if autoClose       		then pkgFrame.autoClose := autoClose;       		if devInstallScript       		then pkgFrame.devInstallScript := devInstallScript;       		if devRemoveScript       		then pkgFrame.devRemoveScript := devRemoveScript;       		end;              	if newtpkg.deletionScript // for 2.0       	then pkgFrame.deletionScript := newtpkgdeletionScript;       	if newtpkg.labels // for 2.0       	then pkgFrame.labels := newtpkg.labels;              	gc();       	local defStore := :GetDefaultStore();       	:init([], defStore, newtPkg.sizeHint, asym);              	local flags :=       		(if partData and newtPkg.dispatchOnly then 0x8000 else 0) +       		(if newtPkg.copyProtected then 0x4000 else 0) +       		(if newtPkg.compressed then 0 else 0x1000);       	newtpkg := NIL;              	:stuffPackage(pkgFrame,       		if isInstance(version,'int) then version else 1,       		if isInstance(copyright,'String)       		then copyright       		else kCopyright && :?GetUserConfig('name), // inherit *** [Newt or Newt's Cape]       		SPrintObject(asym),       		if partData then "auto" else if isbn then "book" else "form", 	// font ???       		flags       		);              	SetValue(progress.currentPath, 'text, "<Installing...>");       	progress:update(nextChunk);              	local pkg :=       		if pkgSoup       		then defStore:RestoreSegmentedPackage(pkgSoup, segments)       		else if Functions.IsVBO exists then defStore:suckPackageFromBinary(segment,{}) //{callFreq: 100, callBack: Functions.Print})       		else defStore:RestorePackage(segment); // "small" package (pre 1.3 ROMs) or VBO (2.0)              	progress:close(); RefreshViews();       	if isinstance(pkg,'int) and pkg<0       	then :error('savePackage, {error: pkg})       	else PlaySound(ROM_funbeep); //if not partData then :addView(asym);       	pkgSoup:?removeAllEntries();              	pkgFrame;       	end,     stuffPackage:       func(pkgFrame,version,devCopyright,packageName,partSym,flags)       begin       	if kProfileOn then EnableProfiling(true);       	local int partOffset := 52;       	:setOffset(0,TRUE);              // PACKAGE HEADER       	StuffCString(segment,  0,"package0");       	StuffCString(segment,  8,"xxxx");       	StuffWord	(segment, 12, flags); //uncompressed,copyprotected,dispatchonly ***       	StuffWord	(segment, 14, 0);       	StuffLong	(segment, 16, version);       	StuffWord	(segment, 20, 0);       	StuffWord	(segment, 22, length(devCopyright));       	StuffWord	(segment, 24, length(devCopyright));       	StuffWord	(segment, 26, length(packageName));              	//StuffLong	(segment, 28, nextChunk); // fill in at end when we know it       	//StuffLong	(segment, 32, 0); // create_time, Mac format -- too big              	local int lo, hi, t := Time(); // minutes       	lo := (Band(t,0xFFFF) * 60) + (TimeInSeconds() mod 60);       	hi := ((t >> 16) * 60) + (lo >> 16);       	StuffWord	(segment, 32, hi);       	StuffWord	(segment, 34, lo);       	//StuffWord	(segment, 36, hi);       	//StuffWord	(segment, 38, lo);       	StuffLong	(segment, 36, 0);       	       	StuffLong	(segment, 40, 0);              // (1) PART HEADER       	:stuffPartHeader(partOffset, devCopyright, packageName, partSym);              	StuffLong	(segment, 44, firstChunk := nextChunk);       	StuffLong	(segment, 48, 1); // num_parts ***              	:stuffChunk(firstChunk,[pkgFrame]);              // fixup PACKAGE HEADER with package length       	if (nextChunk mod kSegSize) <> 0       	then begin       		if (segOffset := nextChunk - segBegin) >= segSize       			or nextChunk < segBegin       		then :setOffset(nextChunk,TRUE);       		SetLength (segment, segOffset);       		end;              	if 0 < segBegin       	then :setOffset(0,TRUE);       	StuffLong	(segment, 28, nextChunk);       	StuffLong	(segment, partOffset+ 4, nextChunk-firstChunk);       	StuffLong	(segment, partOffset+ 8, nextChunk-firstChunk);              	if segEntry then EntryChange(segEntry);       	if kProfileOn       	then EnableProfiling(nil);              	if kDebugOn       	then begin       		Print("package length" && nextChunk);       		Print(["pkgObjF", Length(pkgObjF),       			"pkgAoffs", Length(pkgAoffs),       			"pkgOffs", Length(pkgOffs),]);       		end;       end,     Init:       func(segs,defStore,sizeHint,asym)       begin       	self.segments 	:= segs;       	self.pkgGrid := 8;       	if Functions.IsVBO exists       	then begin       		self.segment := defStore:NewVBO('packageEntry,kSegSize);       		self.segBegin := 0;       		smallPackage := NIL; // for prog label       		end              	else if not smallPackage       	then begin       		self.pkgSoup 	:= defStore:GetSoup(kPkgSoupName);       		if pkgSoup       		then pkgSoup:removeAllEntries()       		else pkgSoup := defStore:CreateSoup(kPkgSoupName,[]);              		self.cursor 	:= Query(pkgSoup,{type: 'index});       		if not isArray(segs) then segments := call BackupPackage with (pkgSoup, segs); // test       		end;              	self.pkgObjs 	:= [];       	self.pkgOffs 	:= [];       	self.pkgObjF   := {};       	self.pkgAObjs  := []; // ***       	self.pkgAOffs  := [];       	self.segSize   := kSegSize; // initially for smallPackage; constant for reg package       	self.keepValue := kDebugOn;              	self.progress := BuildContext(  // not opened.  see :update       		{_proto: protoProgress, // assumes exists ***       		maxProgressValue:       			if sizeHint       			then sizeHint       			else if length(segments)=0       			then 40000       			else length(segments)*kSegSize,       		progressLabel:       			"[" & kVersionString & (if smallPackage then "+S") & "]" &&       			(if isArray(segs) then "Saving" else "Reading") &&       			"Package:  " & asym,       		//heapButton: heapButton, // from Newt       		});       	progress:open();       end,     ArrayDiff:       func(a1,a2,diff)       if length(a1)=length(a2)       then begin       	local i;       	for i:=0 to length(a1)-1       	do if a1[i]<>a2[i] and :ObjDiff(a1,a2,i,diff)       		then return SetAdd(diff,i,nil);       	//NIL;       	end       else SetAdd(diff,'len,nil),     cursor: nil,     extractNum:       func(data, offset, len, shoff)       begin       	// extract 2-4 bytes as a number       	// for len=4, use ExtractLong for "small" nums; otherwise, shoff=-2       	local i, val := 0, sh := shoff, byte;       	for i := len-1 to 0 by -1       	do begin       		byte := ExtractByte(data, offset+i);       		val := val + (if sh < 0 then byte >> -sh else byte << sh);       		sh := sh + 8;       		end;       	val;       end,     segBegin: -kSegSize,     segments: nil,     printPkgEntry:       func(data,offset, type,len,name,const, hframe)       begin       	local vlen, val;       	if type='int       	then val := :extractNum(data, offset, vlen := 2, 0)              	else if type='long       	then begin       		vlen := 4;       		val :=       			if ExtractByte(data, offset) < 0x40       			then ExtractLong(data, offset)       			else :printHexBin(data, offset,4,'H);       		end              	else if type='time       	then begin       		vlen := 4;       		val := ExtractLong(data,offset);       		end              	else if type='char       	then if vlen := len       		then val := :extractString(data, offset, len, nil, 1)       		else begin       			val := ExtractCString(data,offset);       			vlen := StrLen(val)+1;       			end              	else if type='uchar       	then if vlen := len       		then val := ExtractBytes(data,offset,len,'String)       		else begin       			val := :extractString(data, offset, len, 'String, 2);       			vlen := (StrLen(val)+1)*2;       			end;              Print([       	offset, name, val,              	if type='time then DateNTime(val)       	else if isInstance(val,'string) then "len="&vlen // IsString(val)       	else :printHexBin(val,nil,vlen,'H),              	if const       	then if (if isInstance(const,'string) // IsString(val)       			then StrEqual(const,val) else const=val)       		then "OK"       		else "*********"       	else "",       	]);              	hframe.(name) := val;       	offset+vlen;       end,     pkgAObjs: nil,     pkgAOffs: nil,     extractCString2:       func(offset,len)       begin       	if (segOffset := offset - segBegin) >= segSize       		or offset < segBegin       	then :setOffset(offset,NIL);       	local dlen := segSize - segOffset;       	local s := ExtractCString(segment, segOffset);       	if len > dlen       	then begin       Print("splitC" && s);       		s & :ExtractCString2(offset + dlen, len - dlen);       		end       	else s;       end,     printPkgEntries:       func(data,offset, heading, hframe, entries)       begin       	local elen, type, len, name, const;       Print("\n"&heading);       	foreach e in entries       	do begin       		elen := length(e);       		type := e[0];       		len := if elen >= 3 then e[2];       		if isInstance(len,'symbol) // IsSymbol(len)       		then len := hframe.(len); // e.g., 'part_sym_len       		name := if elen >=2 then e[1];       		if not name then name := intern(type&offset);       		const := if elen>=4 then e[3];       		if isInstance(const,'symbol) // IsSymbol(const)       		then const := hframe.(const);       		offset := :printPkgEntry(data,offset, e[0],len,name,const, hframe);       		end;       	offset;       end,     stuffNum:       func native (int offset, int val, int len, int shoff)       begin       	// stuff 1-4 bytes as a number       	if (segOffset := offset - segBegin) >= segSize       		or offset < segBegin       	then :setOffset(offset,TRUE);              	local int i, sh := shoff, segOff := segOffset;       	for i := segOff+len-1 to segOff by -1       	do begin       		StuffByte(segment, i, if sh < 0 then val<< -sh else val >> sh);       		sh := sh + 8;       		end;       end,     firstFrame: true,     shareObj:       func (obj, int offset) // used only by extractXXX       begin       	local cl := Classof(obj);       	if cl<>'instructions and cl<>'literals       	then begin       		AddArraySlot(pkgOffs, offset);       		AddArraySlot(pkgObjs, obj);       		end;       end,     extractBytes2:       func(offset,len,dtype)       begin       	if (segOffset := offset - segBegin) >= segSize       		or offset < segBegin       	then :setOffset(offset,NIL);       	local dlen := segSize - segOffset;       	if len <= dlen       	then ExtractBytes(segment, segOffset, len, dtype)       	else begin       Print("splitB" && dlen);       		BinaryMunger(       			ExtractBytes(segment, segOffset, dlen, dtype), dlen, 0,       			:ExtractBytes2(offset+dlen, len-dlen, dtype), 0, nil);       		end;       end,     StuffCString2:       func native (int offset, str, int start, int len)       begin       	if (segOffset := offset - segBegin) >= segSize       		or offset < segBegin       	then :setOffset(offset,TRUE);       	local int segOff := segOffset;       	local int dlen := segSize - segOff;       	if len<0 then len := call Functions.StrLen with(str)+1;       	local nosplit := len <= dlen;              	// StuffCString break near end of data (last xx bytes?)       	// plus we don't always want to create substr for str       	if start=0 and nosplit and segOff+(len*2) < Length(segment)       	then StuffCString(segment,segOff,str)              	else begin // slower but reliable fallback       		local int i, null := if nosplit then len-1 else -1; // null index?       		for i:=0 to (if nosplit then len else dlen)-1 // len includes null (if null)       		do StuffChar(segment, segOff+i,       			if i=null then 0 else str[start+i]);              		if not nosplit       		then :stuffCString2(offset+dlen, str, start+dlen, len-dlen);       	end;       end,     pkgSoup: nil,     BinDiff:       func(b1,b2,diff)       if length(b1)=length(b2)       then begin       	local i;       	for i:=0 to length(b1)-1       	do if ExtractByte(b1,i) <> ExtractByte(b2,i)       	then return SetAdd(diff,i,nil);       	//NIL;       	end       else SetAdd(diff,'len,nil),     StuffBytes2:       func native (int offset, bytes, int start, int len)       begin       	if (segOffset := offset - segBegin) >= segSize       		or offset < segBegin       	then :setOffset(offset,TRUE);       	local int dlen := segSize - segOffset;       	if len<0 then len := Length(bytes);       	if len <= dlen       	then BinaryMunger(segment,segOffset,len, bytes,start,len)       	else begin       		BinaryMunger(segment,segOffset,dlen, bytes,start,dlen);       		:stuffBytes2(offset+dlen, bytes, start+dlen, len-dlen);       		end;       end,     viewClass: 74,     extractVPUM:       func(offset)       begin       	if (segOffset := offset - segBegin) >= segSize       		or offset < segBegin       	then :setOffset(offset,NIL);              	local kREF := Functions.REF; // avoid compiler warnings       	local byte3 := ExtractByte(segment, segOffset+3);       	local bits2 := Band(byte3, 0x3);              	if bits2=0				// VALUE       	then if ExtractByte(segment,segOffset) < 0x20       		then call kREF with(ExtractLong(segment,segOffset))       		else :extractNum(segment,segOffset,4,-2)              	else begin       		local longVal := ExtractLong(segment,segOffset);       		if bits2=1			// POINTER to Data, Array or Frame       		then :extractChunk(longVal-1)              		else if bits2=3			// MAGIC POINTER ??? Ref?       		then call kREF with(longVal)              		else if byte3=0x52 and	// UNUSUAL/UNICODE       			longVal=0x00055552		// SYMBOL       		then kSymbolType              		else call kREF with (longVal);	// NIL, TRUE, WEAK ARRAY, UNICODE CHAR       		end;       end,     testpackage:       func(ptitle,asym, doit, keepValue)       begin       	local pkgs := GetPackages();       	local ppos := ArrayPos(pkgs,ptitle,0,func(pt,p) StrEqual(pt,p.title));       	local pkg := if ppos then pkgs[ppos];              	local epos := ArrayPos(Extras,asym,0,       			if isInstance(asym,'symbol)       			then func(a,e) a=e.app       			else func(a,e) e.app='copperfield and StrEqual(a,e.isbn)       			);       	local exApp := if epos then Extras[epos];              	if not (doit and pkg and exApp)       	then return Print([pkg, exApp]);              	:init(pkg,:GetDefaultStore(),nil,ptitle);              	local pkgFrame := :extractPackage();       	progress:close();              	if keepValue       	then begin       		Print(:ObjDiff(pkgFrame.part1[0], exApp, '[pathExpr: icon, bits], []));       		Print(:ObjDiff(pkgFrame.part1[0], exApp, '[pathExpr: theForm], []));       		end;       	pkgSoup:removeAllEntries();       	pkgFrame;       end,     stuffVPUM:       func (INT offset, val)       begin       	if isImmediate(val) and isInstance(val,'int) and val > 0x17FFFFFF // isInstance breaks if array class is a number       	then :stuffNum(offset, val, 4, -2); // "big" INT              	else begin       		local int sval :=       			if val=kSymbolType 	// my special symbol flag       			then 0x00055552              			else if isImmediate(val) // IMMEDIATE: "small" INT, NIL, TRUE, WEAK ARRAY, UNICODE CHAR       				or IsMagicPtr(val)  // MAGIC POINTER       			then call Functions.RefOf with (val) // val << 2, (val << 2) + 3 ???              			else // POINTER: FRAME, ARRAY, SYMBOL, BINARY       				:stuffChunk(nextChunk,val)+1;              		if (segOffset := offset - segBegin) >= segSize       			or offset < segBegin       		then :setOffset(offset,TRUE);       		StuffLong(segment, segOffset, sval);       		end;       end    };// After Script for "protoPackage"thisView := protoPackage;begin	if not kDebugOn	then begin		RemoveSlot(thisView,'testPackage);		RemoveSlot(thisView,'ObjDiff);		RemoveSlot(thisView,'FrameDiff);		RemoveSlot(thisView,'BinDiff);		RemoveSlot(thisView,'ArrayDiff);		RemoveSlot(thisView,'shareObj);		RemoveSlot(thisView,'extractBytes2);		RemoveSlot(thisView,'extractChunk);		RemoveSlot(thisView,'extractCString2);		RemoveSlot(thisView,'extractNum);		RemoveSlot(thisView,'extractPackage);		RemoveSlot(thisView,'extractString);		RemoveSlot(thisView,'extractVPUM);		RemoveSlot(thisView,'printHexBin);		RemoveSlot(thisView,'printPkgEntries);		RemoveSlot(thisView,'printPkgEntry);		end;	partData.(pkgSym) := thisView;endconstant |layout_protoPackage| := protoPackage;// End of file protoPackage