// Text of project NewtPack1x.¹ written on 2/10/96 at 8:11 PM// Beginning of text file Project Data// NewtPack (Newt Packages) (autopart) 3.3// Copyright 1995-96 S. Weyer. All Rights Reserved Worldwideconstant kNewtPack := "NewtPack";constant kVersionNum 	:= "3.3";constant kBetaVersion 	:= "b";DefConst('kBuild20, platformVersion.platformFile = '|Newton 2.0|);DefConst('kVersionString,	kVersionNum & kBetaVersion &	(if kDebugOn then "D") &	(if kProfileOn then "P") &	(if not kIgnoreNativeKeyword then "N") &	(if kBuild20 then "-2"));DefConst('kVersion, kNewtPack && kVersionString);Print(kVersion);DefConst('pkgPad, if kBuild20 then 4 else 8);constant kCopyright   := "© 1995-96,"; // used also for dev copyrightconstant kCopyAuthor  := "S. Weyer (portions may be derived from Newtonª Toolkit © 1992-95, Apple Computer, Inc.)";DefConst('kCopyTool, kVersion && kCopyright && kCopyAuthor);constant kNewtSymbol  := '|NewtDevEnv:TKnollSys|;constant kPkgSoupName := "TEMPPKG:TKnollSys";constant kSegSize		 := 4096;constant kPlugType	 := 'protos;constant pkgSym 		 := 'protoPackage;constant progSym 		 := 'protoProgress;constant kTooBig		 := "pkgOffset too big";constant kFakeParent  := '_MyParent_;InstallScript := func(partFrame,removeFrame) // #1begin	local gData := GetGlobals().(kNewtSymbol);	if not gData	then GetGlobals().(EnsureInternal(kNewtSymbol)) :=		gData := EnsureInternal(			{constants: {}, libraries: {}, protos: {}, tools: {}, views: {}, });	gData.(kPlugType).(EnsureInternal(pkgSym))  := partFrame.partData.(pkgSym);	gData.(kPlugType).(EnsureInternal(progSym)) := partFrame.partData.(progSym);end;RemoveScript := func(removeFrame) // #2begin	local protos := GetGlobals().(kNewtSymbol).(kPlugType);	RemoveSlot(protos, pkgSym);	RemoveSlot(protos, progSym);end;partData := {}; // set protoPackage, protoProgress in afterScriptconstant kSymbolType := '|?$_Symbol_$?|;constant eArray := '[];DefConst('eFrame, {});DefConst('orda, ord($a));DefConst('ordz, ord($z));DefConst('kSymCompare, func NATIVE (h1, h2) // [hi,lo,str,sym]  // #5if h1=NIL then -1else if h2=NIL then 1else begin	local ARRAY a1 := h1, a2 := h2;	local INT hi := a1[0]-a2[0], lo;	if hi=0	then if (lo := a1[1]-a2[1])=0		then call Functions.StrCompare with(a1[2],a2[2])		else lo	else hi;	end);DefConst('kFindArray, func NATIVE (ARRAY objs, ARRAY aobj) // #6begin	local INT i, j, alen := Length(aobj);	local aclass := ClassOf(aobj), found;	local ARRAY obj1;	//local kIsArray := Functions.IsArray;	for i:=0 to Length(objs)-2 // skip final NIL	do //if call kIsArray with (objs[i]) then		begin			obj1 := objs[i];			if alen = Length(obj1) and aclass = ClassOf(obj1)			then for j:=0 to (found := alen-1)				do if obj1[j]<>aobj[j] then break found := NIL;			if found then return i;		end;end);DefConst('kSaveOffset, func NATIVE (ARRAY objects, offsets, obj, INT offset, INT pos)begin	local INT last := Length(objects)-1;	if pos < 0	then begin		if objects[last] // check last element		then objects[last] := objects[pos := objects[last]] // remove from chain		else begin			pos := last;			SetLength(objects, pos+2);			SetLength(offsets, (pos+1)*2);			end;		objects[pos] := obj;		StuffWord(offsets, pos*2, offset div pkgPad);		pos; // for later remove		end	else begin		objects[pos] := objects[last]; // add previous front		objects[last] := pos; // add to front of chain//Print([offset,obj]);		ReplaceObject(obj, [_pkgOffset_: offset]);		end;end);DefConst('kGetOffset, func NATIVE (offsets, INT pos)pkgPad *	(ExtractByte(offsets, (pos*2)) * 256 +	 ExtractByte(offsets, (pos*2)+1)));DefConst('kSymHash, func NATIVE (data, INT offset, str, sym)begin	if not str	then str := call Functions.SPrintObject with(sym);	local INT i, ch, tot:=0;	local OrdFn := Functions.Ord;	for i:=0 to call Functions.StrLen with(str)-1	do begin		ch := call OrdFn with(str[i]);		tot := tot + if orda<=ch and ch<=ordz then ch-32 else ch;		end;	local INT lo := 0x79B9 * tot;	local INT hi := (0x9E37 * tot) + (lo >> 16);	if data	then begin		StuffWord(data, offset,   hi);		StuffWord(data, offset+2, lo);		end	else begin // assume array		local ARRAY dd := call Functions.Array with(if sym then 4 else 2, NIL);		dd[offset]   := Band(hi,0xFFFF);		dd[offset+1] := Band(lo,0xFFFF);		if sym		then begin // for sorting			dd[offset+2] := str;			dd[offset+3] := sym;			end;		dd;		end;end);DefConst('kFormInstallScript, func(partFrame) // InstallScript for a normal (part) packagebegin//Print("installing" && partFrame.app);	if Extras exists and isArray(Extras) and ArrayPos(Extras,partFrame.app,0,func(a,e) a=e.app)	then GetRoot():Notify(3,		EnsureInternal("Extras Drawer"),		"Duplicate App" && partFrame.app)	else if HasSlot(partFrame,'devInstallScript)	then begin		partFrame:devInstallScript(partFrame);		partFrame.devInstallScript := NIL;		end;	partFrame.InstallScript := NIL;//Print("end install");end);DefConst('kFormRemoveScript, func(partFrame)	partFrame:?devRemoveScript(partFrame));DefConst('kAutoInstallScript, func(partFrame)begin	local rFrame := EnsureInternal({removeScript: partFrame.devRemoveScript});	partFrame:devInstallScript(partFrame, rFrame);	rFrame;end);DefConst('kDeletionScript, func() nil);if kDebugOnthen DefConst('kArrayEqual, func (ARRAY a1, ARRAY a2)if Length(a1)=Length(a2)	and Classof(a1)=Classof(a2)then begin	local INT i;	for i := 0 to Length(a1)-1	do if a1[i] <> a2[i] then return NIL;	return TRUE;	end);if kDebugOnthen DefConst('kPrintObj, func(off,obj,len)	begin		Write(off & ": [" & len & "] "); Print(obj);	end);// End of text file Project Data// Beginning of file EmptyLayout_view000 :=    {viewBounds: {left: 40, top: 16, right: 152, bottom: 72},     viewFlags: 1,     viewFormat: nil,     viewClass: 74    };constant |layout_EmptyLayout| := _view000;// End of file EmptyLayout// Beginning of file protoProgressprotoProgress :=    {viewBounds: {left: 6, top: 160, right: -6, bottom: 210},     Update:       func(val) //,pathstr,refr)       begin       	//self:open();       	SetValue(currentSize,'text, NumberStr(val));       	SetValue(progressGauge, 'viewValue, max(min(val,maxProgressValue),0));              /*	local elapsed := if startTime       		then TimeInSeconds() - startTime       		else begin       			startTime := TimeInSeconds();       			0;       			end;       	local secs := elapsed mod 60;       	SetValue(elapsedTime, 'text,       		(elapsed div 60) & (if secs < 10 then ":0" else ":") & secs);       */              	//if pathstr then SetValue(currentPath,'text, pathstr); // or set separately       	//if refr then       	RefreshViews();       end,     maxProgressValue: nil,     progressLabel: "",     startTime: nil,     viewSetupDoneScript:       func()       begin       	closebox:hide();       	AddDeferredAction(func(view)       		if Visible(view) then view.closebox:show(),       		[self]);       end,     ReorientToScreen:       @588 //ROM_DefRotateFunc       ,     viewJustify: 48,     _proto: @179    };label :=    {text: "",     viewBounds: {top: 3, left: 1, right: -1, bottom: 15},     viewJustify: 8388656,     viewSetupFormScript:       func()       begin       	text := progressLabel;       	inherited:?viewSetupFormScript();       end,     _proto: @218    };AddStepForm(protoProgress, label);progressGauge :=    {viewBounds: {top: 18, left: 1, right: -1, bottom: 33},     viewSetupFormScript:       func()       begin       	maxValue := maxProgressValue;       	minValue := viewValue := 0;       end,     viewValue: 50,     viewJustify: 48,     _proto: @182    };AddStepForm(protoProgress, progressGauge);StepDeclare(protoProgress, progressGauge, 'progressGauge);currentPath :=    {text: "",     viewBounds: {top: -14, left: 1, right: -85, bottom: -2},     viewJustify: 8388784,     _proto: @218    };AddStepForm(protoProgress, currentPath);StepDeclare(protoProgress, currentPath, 'currentPath);currentSize :=    {text: "0",     viewBounds: {top: -14, left: -80, right: -20, bottom: -2},     viewJustify: 8388769,     _proto: @218    };AddStepForm(protoProgress, currentSize);StepDeclare(protoProgress, currentSize, 'currentSize);closebox := {_proto: @166};AddStepForm(protoProgress, closebox);StepDeclare(protoProgress, closebox, 'closebox);// After Script for "protoProgress"thisView := protoProgress;partData.(progSym) := thisViewconstant |layout_protoProgress| := protoProgress;// End of file protoProgress// Beginning of file protoPackageprotoPackage :=    {     printHexBin:       func(data, offset, len, hub)       begin       	// print Hex, Unicode or Binary format       	local s := if hub='h then "0x" else if hub='u then "\u" else "";       	local digits :=       		if hub='b       		then [       			"0000", //0       			"0001", //1       			"0010", //2       			"0011", //3       			"0100", //4       			"0101", //5       			"0110", //6       			"0111", //7       			"1000", //8       			"1001", //9       			"1010", //A       			"1011", //B       			"1100", //C       			"1101", //D       			"1110", //E       			"1111", //F       			]       		else "0123456789ABCDEF";              	local num := if isBinary(data) then NIL else data;       	local i, lim := len*8 - 4;       	for i:=0 to lim by 4       	do s := s & digits[       		Band(if num       				then num >> (lim-i)       				else ExtractByte(data, offset + (i div 8)) >> ((i+4) mod 8),       			0xF)];       	s;       end,     FrameDiff:       func(f1,f2,diff)       if length(f1)=length(f2)       then begin       	local slot,val;       	local slots1 := foreach slot,val in f1 collect slot;       	local slots2 := foreach slot,val in f2 collect slot;       	if (val := if classof(slots1) <> classof(slots2) then 'class)       		or val := :ArrayDiff(slots1,slots2,[])       	then return SetAdd(diff,['map, val],nil);              	foreach slot in slots1       	do if :ObjDiff(f1,f2,slot,diff)       		then return SetAdd(diff,slot,nil);       	//NIL;       	end       else SetAdd(diff,'len,nil),     ObjDiff:       func(obj1,obj2,path,diff)       begin       	local v1 := obj1, v2 := obj2;       	if path //and length(path)>0       	then begin       		v1 := obj1.(path);       		v2 := obj2.(path);       		end;              	if v1=v2 then return NIL;              	if classof(v1)<>classof(v2)       		or isImmediate(v1) or isImmediate(v2)       		or length(v1)<>length(v2)       	then return diff;              	if isInstance(v1,'string) // IsString(v1)       	then if StrEqual(v1,v2) // make case sensitive?? **       		then NIL       		else diff       	else if isFrame(v1)       	then :FrameDiff(v1,v2,diff)              	else if isArray(v1)       	then :ArrayDiff(v1,v2,diff)              	else if isBinary(v1)       	then :BinDiff(v1,v2,diff)              	else :Notify(3, "unrecognized type for", [v1,v2]);       end,     segOffset: nil,     setOffset:       func NATIVE (INT pkgOffset, alloc)       if cursor       then begin       	local INT segNum := pkgOffset div kSegSize;       	local INT segLen := Length(segments), i, segBeg;       	segBegin := segBeg := segNum * kSegSize;       	segOffset := pkgOffset - segBeg;       	local ARRAY segs := segments;       	if alloc and segEntry       	then call Functions.EntryChange with(segEntry);       	if segNum < segLen       	then begin       		segment := segEntry := NIL;       		segEntry := cursor:GoToKey(segs[segNum]);       		segment := segEntry.packageEntry;       		end       	else if alloc       	then for i:=segLen to segNum       		do begin       if kDebugOn then Print("seg" & i);       			segment := segEntry := NIL;       			segment := SetLength(clone("\u"), kSegSize);       			SetClass(segment, 'packageEntry);       			segEntry := cursor.soup:Add({packageEntry: segment});       			AddArraySlot(segs, call Functions.EntryUniqueId with(segEntry));       			segment;       			end       	else GetRoot():Notify(kNotifyAlert,       			EnsureInternal(kTooBig), SPrintObject(pkgOffset));       	end              else if alloc // small package/VBO       then if segment       	then SetLength(segment, segSize := ((pkgOffset div kSegSize)+1) * kSegSize) // pkgOffset=segOffset       	else begin // 1st time       		segment := SetLength(clone("\u"), kSegSize);       		SetClass(segment, 'packageEntry);       		segBegin := 0;       		segOffset := pkgOffset;       		end              else if segBegin <= pkgOffset and pkgOffset < segSize       then segOffset := pkgOffset              else GetRoot():Notify(kNotifyAlert,       			EnsureInternal(kTooBig), SPrintObject(pkgOffset)),     extractChunk:       func(offset)       begin       	local obj, origOffset := offset, pos := SetContains(pkgOffs,offset);       	if pos       	then return pkgObjs[pos];       		/* begin       		obj := pkgObjs[pos];       		if isArray(obj) and isInstance(classof(obj),'int)       		then begin write("shared framemap "); print(obj); end;       		return obj; //pkgObjs[pos];       		end; */              progress:?update(offset); //,nil,true);              	if (segOffset := offset - segBegin) >= segSize       		or offset < segBegin       	then :setOffset(offset,NIL);       	local ctype := ExtractByte(segment, segOffset+3);       	local len := :extractNum(segment, segOffset, 3, 0);       	local arg := :extractVPUM(offset:=offset+8), val;              	if ctype = 0x40			// DATA       	then begin       		obj := if arg=kSymbolType       			then begin       				if (segOffset := offset+4 - segBegin) >= segSize       					or offset < segBegin       				then :setOffset(offset+4,NIL);       				local shash := [:extractNum(segment,segOffset,  2,0),       									:extractNum(segment,segOffset+2,2,0)];       				val := :ExtractCString2(offset+8, len-16);              				local hilo := call kSymHash with(nil,0,val,nil);       				if not call kArrayEqual with (shash, hilo)       				then Print(["*****", val, shash, hilo]);              				Intern(val);       				end       			else if keepValue then :ExtractBytes2(offset+4, len-12, arg);       //Print(if arg='symbol or arg='string then obj else "<"&arg&":"&(len-12)&">");              		call kPrintObj with (origOffset,obj,len);              		:shareObj(obj,origOffset);       		obj;       		end              	else if ctype = 0x41	// ARRAY       	then begin       //if not IsInstance(arg,'symbol) then print(:printhexbin(segment,segOffset,4,'H)); // type as binary       		local i, alen := (len div 4) - 3;       //Print("["&alen&"]");       		if arg='Array and alen=0       		then eArray       		else begin       			obj := Array(alen,nil);       			if arg       			then SetClass(obj,arg);       			:shareObj(obj,origOffset);       			for i:= 0 to alen-1       			do obj[i] := :extractVPUM(offset:=offset+4);       //if isInstance(arg,'int) then begin write(arg&""); Print(obj); end;       if kDebugOn       then call kPrintObj with (origOffset,obj,len);       			obj;       			end;       		end              	else //if ctype = 0x43 then // FRAME       		begin       //Print(arg);       		if Length(arg)=0       		then eFrame       		else begin       			local slot, slot2;       			obj := {};       			:shareObj(obj,origOffset);       			foreach slot in arg       			do if isArray(slot)       			then begin       Print("??? nested frame map at" && origOffset); // assume no more than 1 level of nesting ***       				foreach slot2 in slot       				do if slot2       				then begin       					val := :extractVPUM(offset:=offset+4);       					if keepValue then obj.(slot2) := val;       					end;       				end       			else if slot       			then begin       					val := :extractVPUM(offset:=offset+4);       					if keepValue then obj.(slot) := val;       					end;       if kDebugOn       then call kPrintObj with (origOffset,obj,len);       			obj;       			end;       		end;       	/* else 					// ERROR       		:Notify(3,"unrecognized chunk",ctype);*/       end,     stuffPartHeader:       func(offset,devCopyright,packageName,partSym)       begin       	StuffLong	(segment, offset+ 0, 0); 	// ***       	//StuffLong	(segment, offset+ 4, 0); // length(part) -- see stuffPackage              	//StuffLong	(segment, offset+ 8, 0); // ditto          StuffCString(segment, offset+12, partSym); // form, book, auto, ***              	StuffLong	(segment, offset+16, 0);       	StuffLong	(segment, offset+20, 0x00000081);              	local strOff := 32;       	local len := (StrLen(devCopyright)+1) * 2; // \u       	BinaryMunger(segment, offset+strOff, len, devCopyright, 0, len);       	strOff := strOff+len;              	len := (StrLen(packageName)+1) * 2; // \u       	BinaryMunger(segment, offset+strOff, len, packageName, 0, len);       	strOff := strOff+len;              	len := StrLen(partSym); // -null              	// now fill these in       	StuffWord	(segment, offset+24, strOff-32);       	StuffWord	(segment, offset+26, len);       	StuffLong	(segment, offset+28, 0);              	StuffCString(segment,offset+strOff,partSym); // form, auto, etc.       	strOff := strOff+len;              	len := StrLen(kCopyTool)+1; // +null       	StuffCString	(segment,offset+strOff,kCopyTool);              	nextChunk := ((offset+strOff+len+pkgPad-1) div pkgPad) * pkgPad; // round to first obj boundary       end,     nextChunk: nil,     segment: nil,     extractPackage:       func(reset)       begin       	if reset // after savePackage       	then begin       		pkgObjs 	:= [];       		pkgOffs 	:= [];       		pkgObjF   := {};       		pkgAObjs  := []; // ***       		pkgAOffs  := [];       		end;              	:setOffset(0,NIL);       	local pkgFrame := {};       	local offset := :printPkgEntries(       		segment,0, "PACKAGE HEADER", pkgFrame,'[       		[char, verify_text,		//   0 'package0' - lets us know this is a package!       			8, "package0"],	       		[char, unknown_text,		//   8 'xxxx' or ' no ' or 'none' - unknown usage       			4, "xxxx",],       		[long, package_flags],	//  12 a combination of the PF_ flags #define'd above       		[long, pkg_version],		//  16 version # of package from NTK dialog       		[int,  zeroPad, nil, 0],//  20 0       		[int,  dcopyright_len],	//  22 length of devel copyright text       		[int,  dcopyright_len2,	//  24 (repeated)       			nil, dcopyright_len],       		[int,  packname_len],	//  26 length of name of package       		[long, package_len],		//  28 length of entire package       		[long, create_time],		//  32 [Mac] creation time/date of package (secs since 1/1/04)       		[time, modif_time],		//  36 [Newton] modification time       		[long, zeroPad, nil, 0],//  40 0       		[long, hdr_length],		//  44 length of package header       		[long, num_parts,			//  48 number of parts in the package       			nil, 1],       		]);              	pkgFrame.real_part_len := pkgFrame.package_len - pkgFrame.hdr_length;              // assume 1 part ***       	offset := :printPkgEntries(       		segment,offset, "PART HEADER", pkgFrame, '[       			[long, part_offset,	//  52 offset of start of part data (within the package)       				nil, 0],	       			[long, part_length,	//  56 length of part       				nil, real_part_len],		       			[long, part_length2,	//  60 length of part       				nil, part_length],       			[char, part_type, 4,	//  64 'form', 'book', 'auto', etc.       				"form"],       			[long, zeroPad,		//  68 0       				nil, 0],       			[long, val81, nil,	//  72 0x00000081       					0x00000081],       			[int,  part_sym_off],//  76 offset from start of text section of the "part symbol"       			[int,  part_sym_len,	//  78 length of "part symbol"       				nil, 4],       			[long, zeroPad,		//  80 0       				nil, 0],       			]);              	offset := :printPkgEntries(       		segment,offset, "STRING SECTION", pkgFrame, '[       			[uchar,dev_copyright,       			   dcopyright_len],	//  84 copyright string from NTK project window.  Null terminated.       			[uchar,packname,       			   packname_len],		// name of package as seen in "Remove Software"       			[char, part_symbol,       			   part_sym_len, part_type],	// 'form' or 'Monaco' or freeform text - seemingly not used.       			[char,NTK_copyright],// 'Newtonª Toolkit Package © 1992-1994, Apple Computer, Inc.'       			]);              	local hlen := pkgFrame.hdr_length;       	pkgFrame := {}; // recycle       	pkgFrame.part1 := :extractChunk(hlen);       	pkgFrame;       end,     extractString:       func(data, offset, len, cl, step) // used only by printPkgEntry       begin       	// return string or unicode string,       	// either with length specified or null terminated       	// for step=1, len=nil  -- use ExtractCString       	// for step=2, len<>nil -- use ExtractBytes       	local i := offset, ch, null:=chr(0), s := "";       	local offlen := if len then offset+len;       	while not offlen or i < offlen       	do begin       		ch := if step=1       			then ExtractChar(data, i);       			else ExtractUniChar(data, i);       		if ch=null then break;               s := s&ch;               i := i+step;       		end;       	s;       end,     firstChunk: nil,     stuffChunk:       func (INT offset, obj)       begin       	local pos, cl := if isFrame(obj) then 'frame else ClassOf(obj);       	local origObj := obj; // esp. for deferredPackageObject       	if cl='symbol // IsSymbol(obj)       	then (if pos := SetContains(pkgObjs, obj)       			then return call kGetOffset with (pkgOffs, pos))       	else begin       		if //isArray(obj) and       			cl='deferredPackageObject       		then begin       			local fn := obj[0], args := obj[1];       			if not isArray(args) then args := [args];       			obj := if isInstance(fn,'symbol)       				then Perform(evalView,fn,args)       				else Apply(fn,args);       			end;              		if isArray(obj)       		then begin       			cl := ClassOf(obj);       			if cl = '_pkgOffset_ // see shareObj       			then return obj[0];       			if isInstance(cl,'int)       			then (if pos := call kFindArray with (pkgAObjs,obj) // frame map       				then return call kGetOffset with (pkgAOffs,pos))       			else pos := SetContains(pkgObjs,obj); // array (probably readonly)       			end       		else pos := SetContains(pkgObjs,obj); // other (readonly) obj       		if pos       		then return call kGetOffset with (pkgOffs,pos);       		cl := if isFrame(obj) then 'frame else ClassOf(obj);       		end;              	local INT origOffset := offset, ctype, len, long1 := 0;       	local val, slot, arg, sym, ro := isReadonly(obj);              // INIT HEADER INFO       	if isFrame(obj) 		// FRAME       	then begin       		if HasSlot(obj,kFakeParent)       		then begin       			RemoveSlot(obj,kFakeParent);       			RemoveSlot(obj,'_parent);       			end;              		ctype := 0x43;       		len := Length(obj);       		arg := Array(len+1,NIL); // frame map       		pos := 0;       		local sortArg := len>20 and not HasSlot(obj,'_nextArgFrame);       		foreach slot,val in obj       		do arg[pos:=pos+1] :=       				if slot and sortArg       				then call kSymHash with(nil,0,nil,slot)       				else slot;              		slot := if HasSlot(obj,'_proto)       			then 4       			else 0;              		if sortArg       		then begin       if kDebugOn then begin Write("sort before: "); Print(arg); end;       			Sort(arg, kSymCompare, nil);       			for pos:=1 to len // fixup (skip 0=nil)       			do arg[pos] := arg[pos][3];       if kDebugOn then begin Write("sort after: "); Print(arg); end;       			slot := slot+1;       			end;              		SetClass(arg,slot);       		len := 4 * (3+len); // frame entry len       		end              	else if isArray(obj)	// ARRAY       	then begin       		ctype := 0x41;       		len := 4 * (3 + Length(obj));       		if origOffset<>firstChunk       		then arg := cl       		else if pkgPad=4 // type=nil       		then long1 := 1; // only in very 1st array!       		end              	else begin 				// SYMBOL, DATA       		ctype := 0x40;       		if isInstance(obj,'symbol) // isInstance(obj)       		then begin       			arg := kSymbolType;       			sym := val := SPrintObject(obj);       			len := 17 + StrLen(val); // + hash(4), null(1)       			end       		else begin       			arg := cl;       			len := 12 + Length(obj);       			end;       		end;              	//local currentPath := progress.currentPath.text;       if ctype<>0x40 then Progress:?update(offset); //, nil, true);       if kDebugOn       then call kPrintObj with (offset,obj,len);              // WRITE CHUNK HEADER INFO       	// update offset ptr for nextChunk, rounded up to "4- or 8-byte" boundary       	nextChunk := nextChunk + ((len+pkgPad-1) div pkgPad) * pkgPad;              	:stuffNum(offset, len, 3, 0); // sets segOffset       	StuffByte(segment, segOffset+3, ctype);              	offset := offset+4;       	if (segOffset := offset - segBegin) >= segSize       		or offset < segBegin       	then :setOffset(offset,TRUE);       	StuffLong(segment, segOffset, long1);              	:stuffVPUM(offset:=offset+4, arg);              	// save offset for object       	pos := if ctype = 0x41 and isInstance(cl,'int) // framemap?       		then call kSaveOffset with (pkgAObjs, pkgAOffs, origObj, origOffset, ro := -1) // save separately. don't remove       		else call kSaveOffset with (pkgObjs,  pkgOffs,  origObj, origOffset, -1);              // WRITE OBJECT       	if ctype = 0x40			// DATA       	then if arg=kSymbolType       		then begin       			offset := offset+4;       			if (segOffset := offset - segBegin) >= segSize       				or offset < segBegin       			then :setOffset(offset,TRUE);       			call kSymHash with (segment, segOffset, val, nil);       			:StuffCString2(offset+4, val, 0, -1);       			ro := true; // leave offset in list       			end       		else :StuffBytes2(offset+4, obj, 0, -1)              	else if ctype = 0x41	// ARRAY       	then foreach val in obj       		do :stuffVPUM(offset := offset+4, val);              	else // if ctype = 0x43 then // FRAME       		foreach slot in arg // since framemap may have been sorted!       		do if slot // skip initial NIL       			then begin       				if not SetContains('[       						class, literals, argFrame, instructions, numArgs,       						_nextArgFrame, _parent, _implementor, preAllocatedContext],       					slot)       				then SetValue(progress.currentPath, 'text, SPrintObject(slot));       				:stuffVPUM(offset:=offset+4, GetSlot(obj,slot));       				end;              // optimization. remove non-readonly entries. replace with [_pkgOffset_: offset]       	if not ro       	then call kSaveOffset with (pkgObjs, pkgOffs, origObj, origOffset, pos);              	origOffset;       end,     segEntry: nil,     pkgObjF: nil,     pkgObjs:       nil // array of some (e.g., symbol) package objects (corresponds to pkgOffs)       ,     pkgOffs:       nil // array of some (e.g., symbol) package offsets       ,     GetDefaultStore:       if kBuild20 then kGetDefaultStoreDeprecatedFunc else kGetDefaultStoreFunc     ,     savePackage:       func(fl)       if fl       then begin       	local newtPkg := appTemplate._package;       	local asym := appTemplate.appSymbol;       	if newtPkg.existingPackage       	then :?RemovePackage(asym);       	:?removeApp(newtPkg.newtSymbol);	// since this is destructive       	RemoveSlot(appTemplate,'_package); // don't save this       	gc();       	local pkgFrame, partData := newtpkg.partData, isbn := appTemplate.isbn;       	local devInstallScript := newtpkg.installScript;       	local devRemoveScript := newtpkg.removeScript;              	local version := if isbn then appTemplate.version else newtpkg.version;       	local copyright := if isbn then appTemplate.copyright else newtpkg.copyright;              	if partData       	then pkgFrame := {       			devInstallScript: devInstallScript,       			devRemoveScript: 	devRemoveScript,       			InstallScript:		kAutoInstallScript,       			partData: 			partData,       			}       	else if isbn       	then pkgFrame := {book: appTemplate}       	else begin       		local stitle := newtpkg.shortTitle, atitle := appTemplate.title;       		local icon := newtpkg.icon;       		local autoClose := newtpkg.autoClose;       		pkgFrame := {       			app: asym,       			text: if stitle then stitle else if isInstance(atitle,'string) then atitle else SPrintObject(asym),       			icon: if icon then icon else genericAppIcon,       			theForm: appTemplate,       			InstallScript: kFormInstallScript,       			RemoveScript:  kFormRemoveScript,       			};       		if autoClose       		then pkgFrame.autoClose := autoClose;       		if devInstallScript       		then pkgFrame.devInstallScript := devInstallScript;       		if devRemoveScript       		then pkgFrame.devRemoveScript := devRemoveScript;       		end;              	if newtpkg.deletionScript // for 2.0       	then pkgFrame.deletionScript := newtpkgdeletionScript;       	if newtpkg.labels // for 2.0       	then pkgFrame.labels := newtpkg.labels;              	gc();       	local defStore := :GetDefaultStore();       	:init([], defStore, newtPkg.sizeHint, asym);              	local flags :=       		(if partData and newtPkg.dispatchOnly then 0x8000 else 0) +       		(if newtPkg.copyProtected then 0x4000 else 0) +       		(if newtPkg.compressed then 0 else 0x1000);       	newtpkg := NIL;              	:stuffPackage(pkgFrame,       		if isInstance(version,'int) then version else 1,       		if isInstance(copyright,'String)       		then copyright       		else kCopyright && :?GetUserConfig('name), // inherit *** [Newt or Newt's Cape]       		SPrintObject(asym),       		if partData then "auto" else if isbn then "book" else "form", 	// font ???       		flags       		);              //if kDebugOn then :extractPackage(true);              	if progress       	then SetValue(progress.currentPath, 'text, "<Installing...>");       	progress:?update(nextChunk);              	local pkg :=       		if pkgSoup       		then defStore:RestoreSegmentedPackage(pkgSoup, segments)       		else if Functions.IsVBO exists then defStore:suckPackageFromBinary(segment,{}) //{callFreq: 100, callBack: Functions.Print})       		else defStore:RestorePackage(segment); // "small" package (pre 1.3 ROMs) or VBO (2.0)              	progress:?close(); RefreshViews();       	if isinstance(pkg,'int) and pkg<0       	then :error('savePackage, {error: pkg})       	else PlaySound(ROM_funbeep); //if not partData then :addView(asym);       	pkgSoup:?removeAllEntries();              	pkgFrame;       	end,     stuffPackage:       func(pkgFrame,version,devCopyright,packageName,partSym,flags)       begin       	if kProfileOn then EnableProfiling(true);       	local int partOffset := 52;       	:setOffset(0,TRUE);              // PACKAGE HEADER       	StuffCString(segment,  0, if pkgPad=4 then "package1xxxx" else "package0xxxx");       	StuffWord	(segment, 12, flags); //uncompressed,copyprotected,dispatchonly ***       	StuffWord	(segment, 14, 0);       	StuffLong	(segment, 16, version);       	StuffWord	(segment, 20, 0);       	StuffWord	(segment, 22, (StrLen(devCopyright)+1)*2); // \u       	StuffWord	(segment, 24, (StrLen(devCopyright)+1)*2);       	StuffWord	(segment, 26, (StrLen(packageName) +1)*2); // \u              	//StuffLong	(segment, 28, nextChunk); // fill in at end when we know it       	//StuffLong	(segment, 32, 0); // create_time, Mac format -- too big              	local int lo, hi, t := Time(); // minutes       	lo := (Band(t,0xFFFF) * 60) + (TimeInSeconds() mod 60);       	hi := ((t >> 16) * 60) + (lo >> 16);       	StuffWord	(segment, 32, hi);       	StuffWord	(segment, 34, lo);       	//StuffWord	(segment, 36, hi);       	//StuffWord	(segment, 38, lo);       	StuffLong	(segment, 36, 0);       	       	StuffLong	(segment, 40, 0);              // (1) PART HEADER       	:stuffPartHeader(partOffset, devCopyright, packageName, partSym);              	StuffLong	(segment, 44, firstChunk := nextChunk);       	StuffLong	(segment, 48, 1); // num_parts ***              	:stuffChunk(firstChunk,[pkgFrame]);              // fixup PACKAGE HEADER with package length       	if (nextChunk mod kSegSize) <> 0       	then begin       		if (segOffset := nextChunk - segBegin) >= segSize       			or nextChunk < segBegin       		then :setOffset(nextChunk,TRUE);       		SetLength (segment, segOffset);       		end;              	if 0 < segBegin       	then :setOffset(0,TRUE);       	StuffLong	(segment, 28, nextChunk);       	StuffLong	(segment, partOffset+ 4, nextChunk-firstChunk);       	StuffLong	(segment, partOffset+ 8, nextChunk-firstChunk);              	if segEntry then EntryChange(segEntry);       	if kProfileOn       	then EnableProfiling(nil);              	if kDebugOn       	then begin       		Print("package length" && nextChunk);       		Print([       			"pkgObjF",	Length(pkgObjF),       			"pkgAoffs", Length(pkgAoffs),       			"pkgOffs", 	Length(pkgOffs),]);       		end;       end,     init:       func(segs,defStore,sizeHint,asym)       begin       	self.pkgObjs 	:= [nil];       	self.pkgOffs 	:= SetClass(clone(""),'bits);       	//self.pkgObjF   := {};       	self.pkgAObjs  := [nil];       	self.pkgAOffs  := SetClass(clone(""),'bits);       	self.segSize   := kSegSize; // initially for smallPackage; constant for reg package       	self.keepValue := kDebugOn;       	self.segments 	:= if isArray(segs) then segs;              	if Functions.IsVBO exists       	then begin       		local pkg;       		self.segBegin := 0;       		smallPackage := NIL; // for prog label       		if not segments       		then pkg := call Functions.GetPkgRef with (segs.title,segs.store);       		self.segment := defStore:NewVBO('packageEntry,       			if pkg then (sizeHint := segSize := Length(pkg)) else kSegSize);       		if pkg       		then :reloFix(BinaryMunger(segment,0,nil,pkg,0,nil),0,[]);       		end              	else if not smallPackage       	then begin       		self.pkgSoup 	:= defStore:GetSoup(kPkgSoupName);       		if pkgSoup       		then pkgSoup:removeAllEntries()       		else pkgSoup := defStore:CreateSoup(kPkgSoupName,[]);              		self.cursor 	:= Query(pkgSoup,{type: 'index});       		if not segments       		then segments := call Functions.BackupPackage with (pkgSoup, segs); // test       		end;              	self.progress := BuildContext(  // not opened.  see :update       		{_proto: protoProgress, // assumes exists ***       		maxProgressValue:       			if sizeHint       			then sizeHint       			else if Length(segments)=0       			then 40000       			else Length(segments)*kSegSize,       		progressLabel:       			"[" & kVersionString & (if smallPackage then "+S") & "]" &&       			(if isArray(segs) then "Saving" else "Reading") &&       			"Pkg:  " & asym,       		//heapButton: heapButton, // from Newt       		});       	progress:open();       end,     ArrayDiff:       func(a1,a2,diff)       if length(a1)=length(a2)       then begin       	local i;       	for i:=0 to length(a1)-1       	do if a1[i]<>a2[i] and :ObjDiff(a1,a2,i,diff)       		then return SetAdd(diff,i,nil);       	//NIL;       	end       else SetAdd(diff,'len,nil),     cursor: nil,     extractNum:       func(data, offset, len, shoff)       begin       	// extract 2-4 bytes as a number       	// for len=4, use ExtractLong for "small" nums; otherwise, shoff=-2       	local i, val := 0, sh := shoff, byte;       	for i := len-1 to 0 by -1       	do begin       		byte := ExtractByte(data, offset+i);       		val := val + (if sh < 0 then byte >> -sh else byte << sh);       		sh := sh + 8;       		end;       	val;       end,     segBegin: -kSegSize,     segments: nil,     printPkgEntry:       func(data,offset, type,len,name,const, hframe)       begin       	local vlen, val;       	if type='int       	then val := :extractNum(data, offset, vlen := 2, 0)              	else if type='long       	then begin       		vlen := 4;       		val :=       			if ExtractByte(data, offset) < 0x40       			then ExtractLong(data, offset)       			else :printHexBin(data, offset,4,'H);       		end              	else if type='time       	then begin       		vlen := 4;       		val := ExtractLong(data,offset);       		end              	else if type='char       	then if vlen := len       		then val := :extractString(data, offset, len, nil, 1)       		else begin       			val := ExtractCString(data,offset);       			vlen := StrLen(val)+1;       			end              	else if type='uchar       	then if vlen := len       		then val := ExtractBytes(data,offset,len,'String)       		else begin       			val := :extractString(data, offset, len, 'String, 2);       			vlen := (StrLen(val)+1)*2;       			end;              Print([       	offset, name, val,              	if type='time then DateNTime(val)       	else if isInstance(val,'string) then "len="&vlen // IsString(val)       	else :printHexBin(val,nil,vlen,'H),              	if const       	then if (if isInstance(const,'string) // IsString(val)       			then StrEqual(const,val) else const=val)       		then "OK"       		else "*********"       	else "",       	]);              	hframe.(name) := val;       	offset+vlen;       end,     pkgAObjs: nil,     pkgAOffs: nil,     extractCString2:       func(offset,len)       begin       	if (segOffset := offset - segBegin) >= segSize       		or offset < segBegin       	then :setOffset(offset,NIL);       	local dlen := segSize - segOffset;       	local s := ExtractCString(segment, segOffset);       	if len > dlen       	then begin       Print("splitC" && s);       		s & :ExtractCString2(offset + dlen, len - dlen);       		end       	else s;       end,     printPkgEntries:       func(data,offset, heading, hframe, entries)       begin       	local elen, type, len, name, const;       Print("\n"&heading);       	foreach e in entries       	do begin       		elen := length(e);       		type := e[0];       		len := if elen >= 3 then e[2];       		if isInstance(len,'symbol) // IsSymbol(len)       		then len := hframe.(len); // e.g., 'part_sym_len       		name := if elen >=2 then e[1];       		if not name then name := intern(type&offset);       		const := if elen>=4 then e[3];       		if isInstance(const,'symbol) // IsSymbol(const)       		then const := hframe.(const);       		offset := :printPkgEntry(data,offset, e[0],len,name,const, hframe);       		end;       	offset;       end,     stuffNum:       func NATIVE (INT offset, INT val, INT len, INT shoff)       begin       	// stuff 1-4 bytes as a number       	if (segOffset := offset - segBegin) >= segSize       		or offset < segBegin       	then :setOffset(offset,TRUE);              	local INT i, sh := shoff, segOff := segOffset;       	for i := segOff+len-1 to segOff by -1       	do begin       		StuffByte(segment, i, if sh < 0 then val<< -sh else val >> sh);       		sh := sh + 8;       		end;       end,     shareObj:       func (obj, int offset) // used only by extractXXX       begin       	local cl := Classof(obj);       	if cl<>'instructions and cl<>'literals       	then begin       		AddArraySlot(pkgOffs, offset);       		AddArraySlot(pkgObjs, obj);       		end;       end,     extractBytes2:       func(offset,len,dtype)       begin       	if (segOffset := offset - segBegin) >= segSize       		or offset < segBegin       	then :setOffset(offset,NIL);       	local dlen := segSize - segOffset;       	if len <= dlen       	then ExtractBytes(segment, segOffset, len, dtype)       	else begin       Print("splitB" && dlen);       		BinaryMunger(       			ExtractBytes(segment, segOffset, dlen, dtype), dlen, 0,       			:ExtractBytes2(offset+dlen, len-dlen, dtype), 0, nil);       		end;       end,     StuffCString2:       func NATIVE (INT offset, str, INT start, INT len)       begin       	if (segOffset := offset - segBegin) >= segSize       		or offset < segBegin       	then :setOffset(offset,TRUE);       	local INT segOff := segOffset;       	local INT dlen := segSize - segOff;       	if len<0 then len := call Functions.StrLen with(str)+1;       	local nosplit := len <= dlen;              	// StuffCString break near end of data (last xx bytes?)       	// plus we don't always want to create substr for str       	if start=0 and nosplit and segOff+(len*2) < Length(segment)       	then StuffCString(segment,segOff,str)              	else begin // slower but reliable fallback       		local INT i, null := if nosplit then len-1 else -1; // null index?       		for i:=0 to (if nosplit then len else dlen)-1 // len includes null (if null)       		do StuffChar(segment, segOff+i,       			if i=null then 0 else str[start+i]);              		if not nosplit       		then :stuffCString2(offset+dlen, str, start+dlen, len-dlen);       	end;       end,     pkgSoup: nil,     BinDiff:       func(b1,b2,diff)       if length(b1)=length(b2)       then begin       	local i;       	for i:=0 to length(b1)-1       	do if ExtractByte(b1,i) <> ExtractByte(b2,i)       	then return SetAdd(diff,i,nil);       	//NIL;       	end       else SetAdd(diff,'len,nil),     StuffBytes2:       func NATIVE (INT offset, bytes, INT start, INT len)       begin       	if (segOffset := offset - segBegin) >= segSize       		or offset < segBegin       	then :setOffset(offset,TRUE);       	local INT dlen := segSize - segOffset;       	if len<0 then len := Length(bytes);       	if len <= dlen       	then BinaryMunger(segment,segOffset,len, bytes,start,len)       	else begin       		BinaryMunger(segment,segOffset,dlen, bytes,start,dlen);       		:stuffBytes2(offset+dlen, bytes, start+dlen, len-dlen);       		end;       end,     viewClass: 74,     extractVPUM:       func(offset)       begin       	if (segOffset := offset - segBegin) >= segSize       		or offset < segBegin       	then :setOffset(offset,NIL);              	local kREF := Functions.REF; // avoid compiler warnings       	local byte3 := ExtractByte(segment, segOffset+3);       	local bits2 := Band(byte3, 0x3);              	if bits2=0				// VALUE       	then if ExtractByte(segment,segOffset) < 0x20       		then call kREF with(ExtractLong(segment,segOffset))       		else :extractNum(segment,segOffset,4,-2)              	else begin       		local longVal := ExtractLong(segment,segOffset);       		if bits2=1			// POINTER to Data, Array or Frame       		then :extractChunk(longVal-1)              		else if bits2=3			// MAGIC POINTER ??? Ref?       		then call kREF with(longVal)              		else if byte3=0x52 and	// UNUSUAL/UNICODE       			longVal=0x00055552		// SYMBOL       		then kSymbolType              		else call kREF with (longVal);	// NIL, TRUE, WEAK ARRAY, UNICODE CHAR       		end;       end,     testpackage:       func(ptitle,asym, doit, keepValue, extract)       //{_parent: tt, _proto: tt.protoPackage}:testPackage("ProtNOS2:TKnollSys",nil, true, nil, true)       begin       	local pkgs := GetPackages();       	local ppos := ArrayPos(pkgs,ptitle,0,func(pt,p) StrEqual(pt,p.title));       	local pkg := if ppos then pkgs[ppos];              /*	local epos := ArrayPos(Extras,asym,0,       			if isInstance(asym,'symbol)       			then func(a,e) a=e.app       			else func(a,e) e.app='copperfield and StrEqual(a,e.isbn)       			);       	local exApp := if epos then Extras[epos];       	if not (doit and pkg and exApp)       	then return Print([pkg, exApp]);       */              	:init(pkg,:GetDefaultStore(),nil,ptitle);              	if not extract       	then return self;              	local pkgFrame := :extractPackage(nil);       	progress:?close();              /*       	if keepValue       	then begin       		Print(:ObjDiff(pkgFrame.part1[0], exApp, '[pathExpr: icon, bits], []));       		Print(:ObjDiff(pkgFrame.part1[0], exApp, '[pathExpr: theForm], []));       		end;       */              	pkgSoup:?removeAllEntries();       	pkgFrame;       end,     reloFix:       func native (pkg, INT offset, ARRAY relo)       begin       	local INT obj;       	if offset=0       	then begin       		// first time. find first object & relo       		// assume this is an array with 1 element       		offset := ExtractWord(pkg, 46);               		// skip header,0,type(+12)       		// [0] should point to next object (+4) in pkg       		// keep relo in array of 4 bytes -- "long" is too big; (words messy)       		obj := offset+16+1;       		relo := [       			ExtractByte(pkg,offset+12),       			ExtractByte(pkg,offset+13),       			ExtractByte(pkg,offset+14) - (obj div 256),       			ExtractByte(pkg,offset+15) - (obj mod 256),       			];       		Print("relo:"); Print(relo);       		end;              	local INT ctype := ExtractByte(pkg,offset+3); // DATA (0x40), ARRAY (0x41), FRAME (0x43)       	local INT clen  :=       		if ctype = 0x40 // DATA       		then 12 // only check type       		else 	ExtractByte(pkg,offset)*65536 +       				ExtractByte(pkg,offset+1)*256 +       				ExtractByte(pkg,offset+2);       	local INT i, p;              	for i := offset+8 to offset+clen-4 by 4       	do if ExtractByte(pkg,i)<>0 and // not already relocated? (assumes pkg < 17M)       			BAND(ExtractByte(pkg, i+3), 0x3) = 1 // obj ptr?       		then begin       			obj := 0;       			for p := 0 to 3       			do obj := obj*256 + (ExtractByte(pkg,i+p) - relo[p]);       			//Print(i & ": " & obj);       			StuffLong(pkg, i, obj);       			obj := obj-1; 		// make ptr an offset       			if obj > offset	// needs fixing only if later in package?       			then :reloFix(pkg, obj, relo);       			end;       	pkg;       end,     stuffVPUM:       func (INT offset, val)       if isImmediate(val) and isInstance(val,'int) and val > 0x17FFFFFF // isInstance breaks if array class is a number       then :stuffNum(offset, val, 4, -2) // "big" INT              else begin       	local INT sval :=       		if val=kSymbolType 	// my special symbol flag       		then 0x00055552              		else if isImmediate(val) // IMMEDIATE: "small" INT, NIL, TRUE, WEAK ARRAY, UNICODE CHAR       			or IsMagicPtr(val)  // MAGIC POINTER       		then call Functions.RefOf with (val) // val << 2, (val << 2) + 3 ???              		else // POINTER: FRAME, ARRAY, SYMBOL, BINARY       			:stuffChunk(nextChunk,val)+1;              	if (segOffset := offset - segBegin) >= segSize       		or offset < segBegin       	then :setOffset(offset,TRUE);       	StuffLong(segment, segOffset, sval);       	end    };// After Script for "protoPackage"thisView := protoPackage;begin		RemoveSlot(thisView,'ObjDiff);		RemoveSlot(thisView,'FrameDiff);		RemoveSlot(thisView,'BinDiff);		RemoveSlot(thisView,'ArrayDiff);	if not kDebugOn	then begin		RemoveSlot(thisView,'testPackage);		RemoveSlot(thisView,'shareObj);		RemoveSlot(thisView,'reloFix);		RemoveSlot(thisView,'extractBytes2);		RemoveSlot(thisView,'extractChunk);		RemoveSlot(thisView,'extractCString2);		RemoveSlot(thisView,'extractNum);		RemoveSlot(thisView,'extractPackage);		RemoveSlot(thisView,'extractString);		RemoveSlot(thisView,'extractVPUM);		RemoveSlot(thisView,'printHexBin);		RemoveSlot(thisView,'printPkgEntries);		RemoveSlot(thisView,'printPkgEntry);		end;	partData.(pkgSym) := thisView;endconstant |layout_protoPackage| := protoPackage;// End of file protoPackage