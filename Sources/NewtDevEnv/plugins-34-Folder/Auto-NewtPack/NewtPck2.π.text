// Text of project NewtPck2.¹ written on 1/20/98 at 4:38 PM
// Beginning of text file Project Data
// NewtPack (Newt Packages) (autopart) 3.4// Copyright 1995-98 S. Weyer. All Rights Reserved Worldwideconstant kAutoCnst 		:= "NewtPack";constant kVersionNum 	:= "3.4";constant kBetaVersion 	:= "";constant kDemoVersion	:= NIL;constant kSlotSymbol 	:= 'protos;constant kConstantSymbol:= 'protoPackage;constant kPartDataSymbol:= 'protoPackage;DefineGlobalConstant('kOmitPkgSlots, '[	// !!!a?	// added by NewtDevEnv	_parent, _MyParent_, existingPackage, pkgSymbol, sizeHint,	newtSymbol, noOpen, devS
Ÿ¸Ÿ€ignature, requires, rFrame,	// standard (already copied/used elsewhere)	version, partData, copyProtected, compressed, dispatchOnly, // !!!g. icon, autoClose,	copyright, installScript, removeScript, shortTitle,	parts, // !!!g	]);// remaining?: DoNotInstall, deletionScript, labels, TapAction, iconPro, ...constant kPartHeaderSize := 32;// more in AutoInstallRemove
Slots, '[	// !!!a?	// added by NewtDevEnv	_parent, _MyParent_, existingPackage, pkgSymbol, sizeHint,	newtSymbol, noOpen, devS
// End of text file Project Data
// Beginning of text file AutoInstallRemove
// AutoInstallRemove// standard for most Newt autopart plugins// except: NewtDraw, protNOS1, Slurpee ??/* "Project Data" precedes this and defines:kAutoCnstkVersionNumkBetaVersionkSlotSymbolkConstantSymbolkPartDataSymbol*/if not IsGlobalConstant('kBuild20)then DefineGlobalConstant('kBuild20,	// '|Newton 2.0| or '|Newton 2.1|		BeginsWith(SprintObject(platformVersion.platformFile), "Newton"));if not IsGlobalConstant('kBuild1x)then DefineGlobalConstant('kBuild1x, not kBuild20);DefineGlobalCo
Ÿ¸Ÿ€nstant('kVersionString,	kVersionNum & kBetaVersion &	(if kDebugOn then $D) &	(if kProfileOn then $P) &	(if not kIgnoreNativeKeyword then $N) &	(if kDemoVersion then $X) &	(if kBuild20 then "-2"));DefineGlobalConstant('kVersion, kAutoCnst && kVersionString);Print(kVersion && DateNTime(time()));if not IsGlobalConstant('kNewtSymbol) thenDefineGlobalConstant('kNewtSymbol, '|NewtDevEnv:TKnollSys|);constant kInstalled		:= 'installed;DefineGlobalConstant('kPkgSymbol,	Intern(kPackageName)); // 
Ÿ¸Ÿ€kAppSymbol='autoPrint(kPkgSymbol);DeclareGlobalFn('DeclareGlobalFn,2);if kBuild1xthen begin	DeclareGlobalFn('GetGlobalVar,1);	DeclareGlobalFn('DefGlobalVar,2);	end;DefineGlobalConstant('kRegExpMin, 5*1440);	// number of mins to expire in (5 days)DefineGlobalConstant('kRegTag, "NG:SK"); 	// this is the app-specific ID for this "lock" DefineGlobalConstant('kRegIspec, {	type: 'index,	IndexPath: 'tag,	startKey: kRegTag,	endTest: func(e) NOT StrEqual(e.tag,kRegTag),});DefineGlobalConst
Ÿ¸Ÿ€ant('kRegExpired, func()begin	//	true - demo has expired	//	nil - full demo or non-demo build.	local prefSoup := GetStores()[0]:GetSoup(ROM_systemSoupName);	local cursor :=		if kBuild20		then prefSoup:Query(kRegIspec)		else Query(prefSoup, kRegIspec);	local prefsEntry := cursor:entry();	prefsEntry and		StrEqual(prefsEntry.tag, kRegTag) and		EntryModTime(prefsEntry) + kRegExpMin < Time()end);if kDemoVersionthen SetPartFrameSlot('DoNotInstall, kRegExpired);DefineGlobalConstant('kEmpt
Ÿ¸Ÿ€yGlobal, {	constants: {}, libraries: {}, protos: {},	tools: {}, views: {}, installed: {},});InstallScript := func(partFrame, removeFrame)if not (kDemoVersion and call kRegExpired with ())then begin	local gData;	if kBuild1x and Functions.GetGlobals exists	then begin		gData := GetGlobals().(kNewtSymbol);		if not gData		then GetGlobals().(EnsureInternal(kNewtSymbol)) := gData := EnsureInternal(kEmptyGlobal);		end	else begin		gData := GetGlobalVar(kNewtSymbol);		if not gData		then DefG
Ÿ¸Ÿ€lobalVar(EnsureInternal(kNewtSymbol), gData := EnsureInternal(kEmptyGlobal));		end;//Print(kVersion);	gData.(kSlotSymbol).(EnsureInternal(kConstantSymbol)) :=		if kpartDataSymbol		then partFrame.partData.(kpartDataSymbol)		else partFrame.partData;	gData.(kInstalled).(EnsureInternal(kPkgSymbol))		  := kVersion;	end;RemoveScript := func(removeFrame)begin	local gData :=		if kBuild1x and Functions.GetGlobals exists		then GetGlobals().(kNewtSymbol)		else GetGlobalVar(kNewtSymbol);	if gDa
Ÿ¸Ÿ€ta	then begin		RemoveSlot(gData.(kSlotSymbol), kConstantSymbol);		RemoveSlot(gData.(kInstalled),  kPkgSymbol);		end;end;
nsureInternal(kConstantSymbol)) :=		if kpartDataSymbol		then partFrame.partData.(kpartDataSymbol)		else partFrame.partData;	gData.(kInstalled).(EnsureInternal(kPkgSymbol))		  := kVersion;	end;RemoveScript := func(removeFrame)begin	local gData :=		if kBuild1x and Functions.GetGlobals exists		then GetGlobals().(kNewtSymbol)		else GetGlobalVar(kNewtSymbol);	if gDa
// End of text file AutoInstallRemove
// Beginning of text file Final Project Data
if kBuild20then begin	DeclareGlobalFn('Query,2);	// so we can use same names	//DefineGlobalConstant('kGetUserConfigFunc, kGetUserConfigDeprecatedFunc);	//DefineGlobalConstant('kGetDefaultStoreFunc, kGetDefaultStoreDeprecatedFunc);	endelse begin	DeclareGlobalFn('AddDeferredCall,2);	DeclareGlobalFn('GetGlobalFn, 1);	DeclareGlobalFn('GetGlobalVar,1);	DeclareGlobalFn('DefGlobalVar,2);	DeclareGlobalFn('LFetch,5);	DeclareGlobalFn('GetDefaultStore,0);	DeclareGlobalFn('IsString,1);	DeclareGlobalFn('
Ÿ¸Ÿ€GetUserConfig,1);	DeclareGlobalFn('DoProgress,3);	DeclareGlobalFn('IsEntryAlias, 1);	DeclareGlobalFn('ResolveEntryAlias, 1);	DeclareGlobalFn('EntryRemoveFromSoupXmit, 2);	DeclareGlobalFn('IsInteger, 1);	DefineGlobalConstant('kTextCompander,	"TLZStoreCompander");	end;DeclareGlobalFn('ClearVBOCache,1);DeclareGlobalFn('GetPkgRef,2);DeclareGlobalFn('BackupPackage,2);DefineGlobalConstant('kVBOFlush, 24*1024);	// !!!e. every 24K or so? ( < 32K?)DefineGlobalConstant('pkgPad, if kBuild20 then 
Ÿ¸Ÿ€4 else 8);constant cr := "\n";constant kCopyright	:= "© 1995-98,"; // used also for dev copyrightconstant kCopyAuthor	:= "S. Weyer (portions may be derived from Newtonª Toolkit © 1992-95, Apple Computer, Inc.)";DefineGlobalConstant('kCopyTool, kVersion && kCopyright && kCopyAuthor);constant kPkgSoupName	:= "TEMPPKG:TKnollSys";constant kSegSize		:= 4096;constant kTooBig		:= "pkgOffset too big";constant kFakeParent	:= '_MyParent_;partData := {}; // set protoPackage, protoProgress in afterSc
Ÿ¸Ÿ€riptconstant kSymbolType := '|?$_Symbol_$?|;constant eArray := '[];DefineGlobalConstant('eFrame, {});DefineGlobalConstant('kSymCompare, func NATIVE (ARRAY a1, ARRAY a2) // [hi,lo,str,sym]  // #5begin	local INT hi := a1[0]-a2[0], lo;	if hi=0	then if (lo := a1[1]-a2[1])=0		then if kBuild20			then StrCompare(a1[2],a2[2])			else call Functions.StrCompare with (a1[2],a2[2])		else lo	else hi;end);DefineGlobalConstant('kFindArray, func NATIVE (ARRAY objs, ARRAY aobj, nocheck) // #6begin
Ÿ¸Ÿ€	local INT i, j, alen := Length(aobj);	local ARRAY obj1;	local aclass := ClassOf(aobj), found;	for i:=0 to Length(objs)-1	do if nocheck or IsArray(objs[i]) then		begin			obj1 := objs[i];			if alen = Length(obj1) and				(nocheck or (isReadonly(obj1) and aclass = ClassOf(obj1)))			then for j:=0 to (found := alen-1)				do if obj1[j]<>aobj[j] then break found := NIL;			if found then return i;		end;end);DefineGlobalConstant('kStuffNum, func NATIVE (data, INT offset, INT val, INT len, INT s
Ÿ¸Ÿ€hoff)begin	// stuff 1-4 bytes as a (big) number, possibly shifted	local INT i, sh := shoff;	for i := offset+len-1 to offset by -1	do begin		StuffByte(data, i, if sh < 0 then val << -sh else val >> sh);		sh := sh + 8;		end;end);DefineGlobalConstant('kExtractNum, func(data, INT offset, INT len, INT shoff)begin	// extract 1-4 bytes as a number	// for len=4, use ExtractLong for "small" nums	local INT i, val := 0, sh := shoff, byte;	for i := len-1 to 0 by -1	do begin		byte := ExtractByte
Ÿ¸Ÿ€(data, offset+i);		val := val + (if sh < 0 then byte >> -sh else byte << sh);		sh := sh + 8;		end;	val;end);DefineGlobalConstant('kSaveOffset, func NATIVE (ARRAY objects, offsets, obj, INT offset, INT pos)begin	local INT last := Length(objects)-1, esize := 2;	local stuffFunc :=		if kBuild20 or Functions.IsVBO exists		then begin			esize := 4;			GetGlobalFn('StuffLong);			end		else Functions.StuffWord;	if pos < 0	then if offsets		then begin			if objects[last] // check last element
Ÿ¸Ÿ€			then objects[last] := objects[pos := objects[last]] // remove from chain			else begin				pos := last;				SetLength(objects, pos+2);				SetLength(offsets, (pos+1)*esize);				end;			objects[pos] := obj;			call stuffFunc with (offsets, pos*esize, offset div pkgPad);			//call kStuffNum with (offsets, pos*esize, offset div pkgPad, esize, 0);			pos; // for later remove			end		else begin // framemap			SetClass(obj, offset);			AddArraySlot(objects,obj);			NIL; //don't remove.   (or last?)	
Ÿ¸Ÿ€		end	else begin // frame map		if pos <= 65535		then begin			objects[pos] := objects[last]; // add previous front			objects[last] := pos; // add to front of chain			end;//Print([offset,obj]);		if kBuild20		then offsets := MakeBinary(esize, '_pkgOffset_)		else begin			SetClass(offsets := Clone(""), '_pkgOffset_);			SetLength(offsets, esize);			end;		call stuffFunc with (offsets, 0, offset div pkgPad);		ReplaceObject(obj, offsets);		end;end);DefineGlobalConstant('kGetOffset, func N
Ÿ¸Ÿ€ATIVE (offsets, INT pos)begin	local INT esize := if kBuild20 or Functions.IsVBO exists then 4 else 2;	pkgPad * call kExtractNum with (offsets, pos*esize, esize, 0);	// pkgPad * (ExtractByte(offsets, (pos*2)) * 256 + ExtractByte(offsets, (pos*2)+1));end);DefineGlobalConstant('orda, Ord($a));DefineGlobalConstant('ordz, Ord($z));DefineGlobalConstant('kSymHash, func NATIVE (data, INT offset, str, sym)begin	local INT i, ch, tot:=0;	local OrdFn := if kBuild1x then Functions.Ord; //GetGlobalFn
Ÿ¸Ÿ€('Ord) else 	for i:=0 to if kBuild20 then StrLen(str)-1 else call Functions.StrLen with(str)-1	do begin		ch := if kBuild20 then Ord(str[i]) else call OrdFn with(str[i]);		tot := tot + if orda<=ch and ch<=ordz then ch-32 else ch;		end;	local INT lo := 0x79B9 * tot;	local INT hi := (0x9E37 * tot) + (lo >> 16);	if data	then begin		StuffWord(data, offset,   hi);		StuffWord(data, offset+2, lo);		end	else begin // assume array		local ARRAY dd :=			if kBuild20			then Array(if sym then 4 els
Ÿ¸Ÿ€e 2, NIL)			else call Functions.Array with (if sym then 4 else 2, NIL);		dd[offset]   := Band(hi,0xFFFF);		dd[offset+1] := Band(lo,0xFFFF);		if sym		then begin // for sorting			dd[offset+2] := str;			dd[offset+3] := sym;			end;		dd;		end;end);DefineGlobalConstant('kFormInstallScript, func(partFrame) // InstallScript for a normal (part) packagebegin//Print("installing" && partFrame.app);	if Extras exists and isArray(Extras) and Functions.ArrayPos exists and		ArrayPos(Extras,partFrame.
Ÿ¸Ÿ€app,0,func(a,e) a=e.app)	then GetRoot():Notify(kNotifyAlert,		EnsureInternal("Extras Drawer"),		"Duplicate App" && partFrame.app)	else if HasSlot(partFrame,'devInstallScript)	then begin		partFrame:devInstallScript(partFrame);		partFrame.devInstallScript := NIL;		end;	partFrame.InstallScript := NIL;//Print("end install");end);DefineGlobalConstant('kFormRemoveScript, func(partFrame)	partFrame:?devRemoveScript(partFrame));DefineGlobalConstant('kAutoInstallScript, func(partFrame)begin	l
Ÿ¸Ÿ€ocal rFrame := EnsureInternal({removeScript: partFrame.devRemoveScript});	partFrame:devInstallScript(partFrame, rFrame);	rFrame;end);DefineGlobalConstant('kDeletionScript, func() nil);if kDebugOnthen DefineGlobalConstant('kArrayEqual, func (ARRAY a1, ARRAY a2)if Length(a1)=Length(a2)	and Classof(a1)=Classof(a2)then begin	local INT i;	for i := 0 to Length(a1)-1	do if a1[i] <> a2[i] then return NIL;	return TRUE;	end);if kDebugOnthen DefineGlobalConstant('kPrintObj, func(off,obj,len
Ÿ¸Ÿ€)	begin		Write(off & ": [" & len & "] "); Print(obj);	end);
Script});	partFrame:devInstallScript(partFrame, rFrame);	rFrame;end);DefineGlobalConstant('kDeletionScript, func() nil);if kDebugOnthen DefineGlobalConstant('kArrayEqual, func (ARRAY a1, ARRAY a2)if Length(a1)=Length(a2)	and Classof(a1)=Classof(a2)then begin	local INT i;	for i := 0 to Length(a1)-1	do if a1[i] <> a2[i] then return NIL;	return TRUE;	end);if kDebugOnthen DefineGlobalConstant('kPrintObj, func(off,obj,len
// End of text file Final Project Data
// Beginning of file AnEmptyLayout
_v74_0 :=
    {viewBounds: {left: 40, top: 16, right: 152, bottom: 72},
     viewClass: 74 /* clView */
    };


constant |layout_AnEmptyLayout| := _v74_0;
// End of file AnEmptyLayout
// Beginning of file protoProgress
protoProgress :=
    {viewBounds: {left: 6, top: 155, right: -6, bottom: 223},
     viewSetupDoneScript:
       func()begin	closebox:hide();	AddDeferredAction(func(view) // just 1.x		if Visible(view) then view.closebox:show(), [self]);end
       ,
     viewJustify: 48,
     ReOrientToScreen:
       func()begin //@588 //ROM_DefRotateFunc	:SyncView();	:RedoChildren();end
       ,
     setStatus:
       func(type, options) // same call as DoProgressif Visible(self)then begin	local val;	if not StrFilled(val := statusText.text) and val	// only 1st time (assume unchanging)	then SetValue(statusText, 'text, val);	if val := options.gauge	// %	then SetValue(gauge, 'viewValue, max(min(val,100),0));	if val := options.titleText	then SetValue(titleText, 'text, val);/*	local elapsed := if startTime		then TimeInSeconds() - startTime		else begin			startTime := TimeInSeconds();			0;			end;	local secs := elapsed mod 60;	SetValue(elapsedTime, 'text,		(elapsed div 60) & (if secs < 10 then ":0" else $:) & secs);*/	RefreshViews();	endelse begin	self.curOptions := options;	self:open();	end;
       ,
     _proto: @179 /* protoFloater */
    };

appIcon :=
    {viewBounds: {left: 0, top: 0, right: 31, bottom: 29},
     viewSetupFormScript:
       func()if curOptions.iconthen begin	icon := curOptions.icon;	curOptions.icon := nil;	// avoid reshowing	end
       ,
     icon: nil,
     viewFlags: 1,
     viewClass: 76 /* clPictureView */
    };
AddStepForm(protoProgress, appIcon);



statusText :=
    {text: "",
     viewBounds: {top: 2, left: 33, right: -1, bottom: 26},
     viewJustify: 48,
     viewSetupFormScript:
       func()if StrFilled(curOptions.statusText)then text := curOptions.statusText
     ,
     _proto: @218 /* protoStaticText */
    };
AddStepForm(protoProgress, statusText);
StepDeclare(protoProgress, statusText, 'statusText);



gauge :=
    {viewBounds: {top: 29, left: 1, right: -1, bottom: 43},
     viewSetupFormScript:
       func()begin	local val := curOptions.gauge;	if val	then begin		viewValue := val;	// usually 0		minValue  := 0;		maxValue  := 100;		end	else viewFlags := 0;end
       ,
     viewValue: 50,
     viewJustify: 48,
     _proto: @182 /* protoGauge */
    };
AddStepForm(protoProgress, gauge);
StepDeclare(protoProgress, gauge, 'gauge);



titleText :=
    {text: "",
     viewBounds: {top: -25, left: 1, right: -1, bottom: -1},
     viewJustify: 176,
     viewSetupFormScript:
       func()if StrFilled(curOptions.titleText)then text := curOptions.titleText
     ,
     _proto: @218 /* protoStaticText */
    };
AddStepForm(protoProgress, titleText);
StepDeclare(protoProgress, titleText, 'titleText);



closebox := {_proto: @166 /* protoCloseBox */};
AddStepForm(protoProgress, closebox);
StepDeclare(protoProgress, closebox, 'closebox);




constant |layout_protoProgress| := protoProgress;
// End of file protoProgress
// Beginning of file protoPackage
protoPackage :=
    {
     printHexBin:
       func(data, offset, len, hub)begin	// print Hex, Unicode or Binary format	local s := if hub='h then "0x" else if hub='u then "\u" else "";	local digits :=		if hub='b		then [			"0000", //0			"0001", //1			"0010", //2			"0011", //3			"0100", //4			"0101", //5			"0110", //6			"0111", //7			"1000", //8			"1001", //9			"1010", //A			"1011", //B			"1100", //C			"1101", //D			"1110", //E			"1111", //F			]		else "0123456789ABCDEF";	local num := if isBinary(data) then NIL else data;	local i, lim := len*8 - 4;	for i:=0 to lim by 4	do s := s & digits[		Band(if num				then num >> (lim-i)				else ExtractByte(data, offset + (i div 8)) >> ((i+4) mod 8),			0xF)];	s;end
       ,
     FrameDiff:
       func(f1,f2,diff)if length(f1)=length(f2)then begin	local slot,val;	local slots1 := foreach slot,val in f1 collect slot;	local slots2 := foreach slot,val in f2 collect slot;	if (val := if classof(slots1) <> classof(slots2) then 'class)		or val := :ArrayDiff(slots1,slots2,[])	then return SetAdd(diff,['map, val],nil);	foreach slot in slots1	do if :ObjDiff(f1,f2,slot,diff)		then return SetAdd(diff,slot,nil);	//NIL;	endelse SetAdd(diff,'len,nil)
       ,
     ObjDiff:
       func(obj1,obj2,path,diff)begin	local v1 := obj1, v2 := obj2;	if path //and length(path)>0	then begin		v1 := obj1.(path);		v2 := obj2.(path);		end;	if v1=v2 then return NIL;	if classof(v1)<>classof(v2)		or isImmediate(v1) or isImmediate(v2)		or length(v1)<>length(v2)	then return diff;	if isInstance(v1,'string) // IsString(v1)	then if StrEqual(v1,v2) // make case sensitive?? **		then NIL		else diff	else if isFrame(v1)	then :FrameDiff(v1,v2,diff)	else if isArray(v1)	then :ArrayDiff(v1,v2,diff)	else if isBinary(v1)	then :BinDiff(v1,v2,diff)	else :Notify(3, "unrecognized type for", [v1,v2]);end
       ,
     segOffset: nil,
     setOffset:
       func NATIVE (INT pkgOffset, alloc)if kBuild1x and cursorthen begin	local INT segNum := pkgOffset div kSegSize;	local INT segLen := Length(segments), i, segBeg;	segBegin := segBeg := segNum * kSegSize;	segOffset := pkgOffset - segBeg;	local ARRAY segs := segments;	if alloc and segEntry	then call Functions.EntryChange with(segEntry);	if segNum < segLen	then begin		segment := segEntry := NIL;		segEntry := cursor:GoToKey(segs[segNum]);		segment := segEntry.packageEntry;		end	else if alloc	then for i := segLen to segNum		do beginif kDebugOn then Print("seg" & i);			segment := segEntry := NIL;			segment := SetLength(clone("\u"), kSegSize);			SetClass(segment, 'packageEntry);			segEntry := cursor.soup:Add({packageEntry: segment});			AddArraySlot(segs, call Functions.EntryUniqueId with (segEntry));			segment;			end	else GetRoot():Notify(kNotifyAlert,			EnsureInternal(kTooBig), SPrintObject(pkgOffset));	endelse if alloc // small package/VBOthen if segment	then begin		SetLength(segment, segSize := ((pkgOffset div kSegSize)+1) * kSegSize); // pkgOffset=segOffset		if (kBuild20 or nextFlush) and segSize >= nextFlush		// !!!e		then begin			ClearVBOCache(segment);			ClearVBOCache(pkgOffs);			nextFlush := nextFlush + kVBOFlush;			end;		end	else begin // 1st time		if kBuild20		then segment := MakeBinary(kSegSize, 'packageEntry)		else begin			segment := SetLength(Clone("\u"), kSegSize);			SetClass(segment, 'packageEntry);			end;		segBegin := 0;		segOffset := pkgOffset;		endelse if segBegin <= pkgOffset and pkgOffset < segSizethen segOffset := pkgOffsetelse GetRoot():Notify(kNotifyAlert,			EnsureInternal(kTooBig), SPrintObject(pkgOffset))
       ,
     smallPackage: nil,
     extractChunk:
       func(offset)begin	local obj, origOffset := offset, pos := SetContains(pkgOffs,offset);	if pos	then return pkgObjs[pos];		/* begin		obj := pkgObjs[pos];		if isArray(obj) and isInstance(classof(obj),'int)		then begin write("shared framemap "); print(obj); end;		return obj; //pkgObjs[pos];		end; */progress:?update(offset); //,nil,true);	if (segOffset := offset - segBegin) >= segSize		or offset < segBegin	then :setOffset(offset,NIL);	local ctype := ExtractByte(segment, segOffset+3);	local len := :extractNum(segment, segOffset, 3, 0);	local arg := :extractVPUM(offset:=offset+8), val;	if ctype = 0x40			// DATA	then begin		obj := if arg=kSymbolType			then begin				if (segOffset := offset+4 - segBegin) >= segSize					or offset < segBegin				then :setOffset(offset+4,NIL);				local shash := [:extractNum(segment,segOffset,  2,0),									:extractNum(segment,segOffset+2,2,0)];				val := :ExtractCString2(offset+8, len-16);				local hilo := call kSymHash with(nil,0,val,nil);				if not call kArrayEqual with (shash, hilo)				then Print(["*****", val, shash, hilo]);				Intern(val);				end			else if keepValue then :ExtractBytes2(offset+4, len-12, arg);//Print(if arg='symbol or arg='string then obj else "<"&arg&":"&(len-12)&">");		call kPrintObj with (origOffset,obj,len);		:shareObj(obj,origOffset);		obj;		end	else if ctype = 0x41	// ARRAY	then begin//if not IsInstance(arg,'symbol) then print(:printhexbin(segment,segOffset,4,'H)); // type as binary		local i, alen := (len div 4) - 3;//Print("["&alen&"]");		if arg='Array and alen=0		then eArray		else begin			obj := Array(alen,nil);			if arg			then SetClass(obj,arg);			:shareObj(obj,origOffset);			for i:= 0 to alen-1			do obj[i] := :extractVPUM(offset:=offset+4);//if isInstance(arg,'int) then begin write(arg&""); Print(obj); end;if kDebugOnthen call kPrintObj with (origOffset,obj,len);			obj;			end;		end	else //if ctype = 0x43 then // FRAME		begin//Print(arg);		if Length(arg)=0		then eFrame		else begin			local slot, slot2;			obj := {};			:shareObj(obj,origOffset);			foreach slot in arg			do if isArray(slot)			then beginPrint("??? nested frame map at" && origOffset); // assume no more than 1 level of nesting ***				foreach slot2 in slot				do if slot2				then begin					val := :extractVPUM(offset:=offset+4);					if keepValue then obj.(slot2) := val;					end;				end			else if slot			then begin					val := :extractVPUM(offset:=offset+4);					if keepValue then obj.(slot) := val;					end;if kDebugOnthen call kPrintObj with (origOffset,obj,len);			obj;			end;		end;	/* else 					// ERROR		:Notify(3,"unrecognized chunk",ctype);*/end
       ,
     stuffPartHeader:
       func(INT offset, ARRAY parts, devCopyright, packageName) // !!!gbegin	// hoff = start of variable length area (after all part headers)	local INT hoff := offset + (kPartHeaderSize * Length(parts)), i, strOff := 0, len;	local part, t;	// write copyright and packagename first (pointers already written in packageHeader)	len := (StrLen(devCopyright)+1) * 2; // \u	BinaryMunger(segment, hoff+strOff, len, devCopyright, 0, len);	strOff := strOff+len;	len := (StrLen(packageName)+1) * 2; // \u	BinaryMunger(segment, hoff+strOff, len, packageName, 0, len);	strOff := strOff+len;	//len := StrLen(kCopyTool)+1; // +null !!!g omitted	StuffCString(segment, hoff+strOff, kCopyTool);	strOff := strOff + StrLen(kCopyTool);	for i:=0 to Length(parts)-1	do begin		part := parts[i];		//StuffLong	(segment, offset+ 0, 0); 	// offset to beginning of part -- see stuffPackage		//StuffLong	(segment, offset+ 4, 0); 	// compressed length -- see stuffPackage		//StuffLong	(segment, offset+ 8, 0); 	// uncompressed length -- see stuffPackage		StuffCString(segment, offset+12, part.type);	// !!!g. form, book, auto, ***		StuffLong	(segment, offset+16, 0);			// reserved. should be 0		StuffLong	(segment, offset+20, if (t := part.flags) then t else 0x00000081);	// !!!g.		if ((t := part.notification) or t := part.type) and			(if kBuild20 then IsString(t) else isInstance(t, 'string)) and			(len := StrLen(t)) > 0		then begin			StuffCString(segment, hoff+strOff, t);	// ascii-null			StuffWord	(segment, offset+24, strOff);			StuffWord	(segment, offset+26, len);			strOff := strOff+len;			end		else StuffLong(segment, offset+24, 0);		if (t := part.compressor) and			(if kBuild20 then IsString(t) else isInstance(t, 'string)) and			(len := StrLen(t)) > 0		then begin			StuffCString(segment, hoff+strOff, t);	// ascii-null			StuffWord	(segment, offset+28, strOff);			StuffWord	(segment, offset+30, len);			strOff := strOff+len;			end		else StuffLong(segment, offset+28, 0);		offset := offset + kPartHeaderSize;		end;	// start of data for 1st part after variable length area	nextChunk := ((hoff + strOff + pkgPad - 1) div pkgPad) * pkgPad; // round to first obj boundaryend
       ,
     nextChunk: nil,
     segment: nil,
     extractPackage:
       func(reset)begin	if reset // after savePackage	then begin		pkgObjs 	:= [];		pkgOffs 	:= [];		pkgAObjs  := []; // ***		pkgAOffs  := [];		end;	:setOffset(0,NIL);	local pkgFrame := {};	local offset := :printPkgEntries(		segment,0, "PACKAGE HEADER", pkgFrame,'[		[char, verify_text,		//   0 'package0' - lets us know this is a package!			8, "package0"],			[char, unknown_text,		//   8 'xxxx' or ' no ' or 'none' - unknown usage			4, "xxxx",],		[long, package_flags],	//  12 a combination of the PF_ flags #define'd above		[long, pkg_version],		//  16 version # of package from NTK dialog		[int,  zeroPad, nil, 0],//  20 0		[int,  dcopyright_len],	//  22 length of devel copyright text		[int,  dcopyright_len2,	//  24 (repeated)			nil, dcopyright_len],		[int,  packname_len],	//  26 length of name of package		[long, package_len],		//  28 length of entire package		[long, create_time],		//  32 [Mac] creation time/date of package (secs since 1/1/04)		[time, modif_time],		//  36 [Newton] modification time		[long, zeroPad, nil, 0],//  40 0		[long, hdr_length],		//  44 length of package header		[long, num_parts,			//  48 number of parts in the package			nil, 1],		]);	pkgFrame.real_part_len := pkgFrame.package_len - pkgFrame.hdr_length;// assume 1 part ***	offset := :printPkgEntries(		segment,offset, "PART HEADER", pkgFrame, '[			[long, part_offset,	//  52 offset of start of part data (within the package)				nil, 0],				[long, part_length,	//  56 length of part				nil, real_part_len],					[long, part_length2,	//  60 length of part				nil, part_length],			[char, part_type, 4,	//  64 'form', 'book', 'auto', etc.				"form"],			[long, zeroPad,		//  68 0				nil, 0],			[long, val81, nil,	//  72 0x00000081					0x00000081],			[int,  part_sym_off],//  76 offset from start of text section of the "part symbol"			[int,  part_sym_len,	//  78 length of "part symbol"				nil, 4],			[long, zeroPad,		//  80 0				nil, 0],			]);	offset := :printPkgEntries(		segment,offset, "STRING SECTION", pkgFrame, '[			[uchar,dev_copyright,			   dcopyright_len],	//  84 copyright string from NTK project window.  Null terminated.			[uchar,packname,			   packname_len],		// name of package as seen in "Remove Software"			[char, part_symbol,			   part_sym_len, part_type],	// 'form' or 'Monaco' or freeform text - seemingly not used.			[char,NTK_copyright],// 'Newtonª Toolkit Package © 1992-1994, Apple Computer, Inc.'			]);	local hlen := pkgFrame.hdr_length;	pkgFrame := {}; // recycle	pkgFrame.part1 := :extractChunk(hlen);	pkgFrame;end
       ,
     extractString:
       func(data, offset, len, cl, step) // used only by printPkgEntrybegin	// return string or unicode string,	// either with length specified or null terminated	// for step=1, len=nil  -- use ExtractCString	// for step=2, len<>nil -- use ExtractBytes	local i := offset, ch, null:=chr(0), s := "";	local offlen := if len then offset+len;	while not offlen or i < offlen	do begin		ch := if step=1			then ExtractChar(data, i);			else ExtractUniChar(data, i);		if ch=null then break;        s := s&ch;        i := i+step;		end;	s;end
       ,
     firstChunk: nil,
     stuffChunk:
       func (INT offset, obj)begin	local pos, val, arg, sym, origObj := obj; // esp. for entryAliases, deferredPackageObject	if (kBuild20 or Functions.IsEntryAlias) and not isFrame(obj) and IsEntryAlias(obj)	// !!!d,b	then begin		val := ResolveEntryAlias(obj);		obj := if (sym := val.appSymbol)			then Perform(GetRoot().(sym), val.appMsg, [val.data])			else val.data;		EntryRemoveFromSoupXmit(val, nil);	// !!!c		end;	local cl := if isFrame(obj) then 'frame else ClassOf(obj);	if //isArray(obj) and		cl='deferredPackageObject	then begin		local fn := obj[0], args := obj[1];		if not isArray(args) then args := [args];		obj := if (if kBuild20 then IsSymbol(fn) else isInstance(fn,'symbol))			then Perform(evalView,fn,args)			else Apply(fn,args);		cl := if isFrame(obj) then 'frame else ClassOf(obj);		end;	if cl = '_pkgOffset_ // and isBinary(obj)	then return call kGetOffset with (obj,0);	local ro := isReadonly(obj);	if isArray(obj)	then begin		if not ro and	// a computed framemap?			(if kBuild20 then IsInteger(cl) else isInstance(cl,'int))		then (if pos := call kFindArray with (pkgAObjs,obj,true) // frame map				then return ClassOf(pkgAObjs[pos])) //call kGetOffset with (pkgAOffs,pos))		else if not (pos := SetContains(pkgObjs,obj)) // array (probably readonly)					and ro and (cl='pathExpr or if kBuild20 then IsInteger(cl) else isInstance(cl,'int))		then pos := call kFindArray with (pkgObjs,obj,nil);		end	else pos := SetContains(pkgObjs,obj); // other (readonly) obj	if pos	then return call kGetOffset with (pkgOffs,pos);	local INT origOffset := offset, ctype, len, long1 := 0;	local slot, frameMap;// INIT HEADER INFO	if isFrame(obj) 		// FRAME	then begin		if HasSlot(obj,kFakeParent)		then begin			RemoveSlot(obj,kFakeParent);			RemoveSlot(obj,'_parent);			end;		ctype := 0x43;		len := Length(obj);		local sortArg := len>20 and not HasSlot(obj,'_nextArgFrame);		arg :=			foreach slot,val in obj  // frame map w/o initial NIL			collect if slot and sortArg				then call kSymHash with (nil, 0, Stringer([slot]), slot)				else slot;		slot := if HasSlot(obj,'_proto)			then 4			else 0;		if sortArg		then begin//if kDebugOn then begin Write("sort before: "); Print(arg); end;			Sort(arg, kSymCompare, nil);			for pos:=0 to len-1 // fixup			do arg[pos] := arg[pos][3];//if kDebugOn then begin Write("sort after: "); Print(arg); end;			slot := slot+1;			end;		SetClass(arg,slot);		len := 4 * (3+len); // frame entry len		end	else if isArray(obj)	// ARRAY	then begin		ctype := 0x41;		len := 4 * (3 + Length(obj));		if (if kBuild20 then IsInteger(cl) else isInstance(cl,'int)) and			(len=12 or obj[0]) and not ro // our framemap?		then frameMap := len := len+4;		if origOffset<>firstChunk		then arg := cl		else if pkgPad=4 // type=nil		then long1 := 1; // only in very 1st array!		end	else begin 				// SYMBOL, DATA		ctype := 0x40;		if (if kBuild20 then IsSymbol(obj) else isInstance(obj,'symbol))		then begin			arg := kSymbolType;			sym := val := Stringer([obj]); // SPrintObject bug for symbols over 63 chars!			len := 17 + StrLen(val); // + hash(4), null(1)			end		else begin			arg := cl;			len := 12 + Length(obj);			end;		end;	//local currentPath := progress.currentPath.text;//if ctype<>0x40 then Progress:?update(offset); //, nil, true);if kDebugOnthen call kPrintObj with (offset, obj, len);// WRITE CHUNK HEADER INFO	// update offset ptr for nextChunk, rounded up to "4- or 8-byte" boundary	nextChunk := nextChunk + ((len+pkgPad-1) div pkgPad) * pkgPad;	if (segOffset := offset - segBegin) >= segSize		or offset < segBegin	then :setOffset(offset,TRUE);	call kStuffNum with (segment, segOffset, len, 3, 0);	StuffByte(segment, segOffset+3, ctype);	offset := offset+4;	if (segOffset := offset - segBegin) >= segSize		or offset < segBegin	then :setOffset(offset,TRUE);	StuffLong(segment, segOffset, long1);	:stuffVPUM(offset:=offset+4, arg);// WRITE OBJECT	if ctype = 0x40			// DATA	then if arg=kSymbolType		then begin			// keep symbol entry in pkgObjs			call kSaveOffset with (pkgObjs,  pkgOffs,  origObj, origOffset, -1);			offset := offset+4;  			if (segOffset := offset - segBegin) >= segSize				or offset < segBegin			then :setOffset(offset,TRUE);			call kSymHash with (segment, segOffset, val, nil);			:StuffCString2(offset+4, val, 0, -1);			pos := NIL; // don't remove			end		else begin			:StuffBytes2(offset+4, obj, 0, -1);			if not (ro and cl='instructions)			then call kSaveOffset with (pkgObjs,  pkgOffs,  origObj, origOffset, if ro then -1 else 65536);			pos := NIL; // don't remove			end	else if ctype = 0x41	// ARRAY	then begin		if frameMap		then begin			pos := call kSaveOffset with (pkgAObjs, pkgAOffs, origObj, origOffset, -1);			:stuffVPUM(offset := offset+4, NIL); // extra NIL at beginning. don't remove			end		else pos := if not (ro and cl='literals)			then call kSaveOffset with (pkgObjs,  pkgOffs,  origObj, origOffset, -1);		foreach val in obj		do :stuffVPUM(offset := offset+4, val);		end	else // if ctype = 0x43 then // FRAME		begin			pos :=				if not (ro and Length(arg) >= 3 and arg[0]='_nextArgFrame and 					arg[1]='_Parent and arg[2]='_implementor)				then call kSaveOffset with (pkgObjs,  pkgOffs,  origObj, origOffset, -1);			foreach slot in arg // since framemap may have been sorted!			do begin				if not SetContains('[						class, literals, argFrame, instructions, numArgs,						_nextArgFrame, _parent, _implementor, preAllocatedContext],					slot)				then begin					progressOptions.titleText := slot & unicodeCR & nextChunk;					if progressOptions.maxGauge					then progressOptions.gauge := RIntToL(nextChunk / progressOptions.maxGauge * 100);					progressView:SetStatus(progressOptions.type, progressOptions);					end;				:stuffVPUM(offset:=offset+4, GetSlot(obj,slot));				end;		end;	// optimization. remove non-readonly entries. replace with <_pkgOffset_: offset>	if pos and not ro	then call kSaveOffset with (pkgObjs, pkgOffs, origObj, origOffset, pos);	origOffset;end
       ,
     segEntry: nil,
     pkgObjs:
       nil // array of some (e.g., symbol) package objects (corresponds to pkgOffs)
       ,
     pkgOffs:
       nil // array of some (e.g., symbol) package offsets
       ,
     savePackage:
       func() // !!!gbegin	local newtPkg := appTemplate._package, pkg := -1;	RemoveSlot(appTemplate,'_package); // don't save this//Print(newtpkg); Print(appTemplate);	self.nos20 := kBuild20 or Functions.isVBO;	// !!!f	local psym := newtPkg.pkgSymbol, sym, val;	if not psym	then psym := appTemplate.appSymbol;	local pkgFrame, partData := newtpkg.partData, isbn := appTemplate.isbn;	local devInstallScript := newtpkg.installScript;	local devRemoveScript := newtpkg.removeScript;	local icon := newtpkg.icon;	local pkgType := if partData then "auto" else if isbn then "book" else "form";	local version := if isbn then appTemplate.version else newtpkg.version;	local copyright := if isbn then appTemplate.copyright else newtpkg.copyright;	if kBuild20 or nos20	then begin		if not isString(copyright)		then copyright := kCopyright && GetUserConfig('name);		if not IsInteger(version) then version := 1;		end	else begin		if not isInstance(copyright, 'string)		then copyright := kCopyright && call kGetUserConfigFunc with('name);		if not isInstance(version, 'int) then version := 1;		end;//Print(copyright); Print(version);	local stitle := newtpkg.shortTitle, atitle;	// !!!h. moved earlier from app for autopart too	if not stitle 	then stitle :=		if isInstance(atitle := if partData then newtpkg.text else appTemplate.title, 'string)		then atitle		else SPrintObject(psym);	if partData	then begin		pkgFrame := {			devInstallScript: 	devInstallScript,			devRemoveScript: 	devRemoveScript,			InstallScript:		kAutoInstallScript,			partData: 			partData,			text:				stitle,				// !!!h. added always			//icon:				// !!!g. if any copied below			};		end	else if isbn	then begin		pkgFrame := {book: appTemplate};		icon := appTemplate.icon;		if appTemplate.help		then pkgFrame.help := true;		//appTemplate.BookInstallScript, BookRemoveScript		end	else begin		pkgFrame := {			app: psym,			text: stitle,	// !!!h			icon: if icon then icon else icon := genericAppIcon, // maybe copied again below			theForm: appTemplate,			InstallScript: kFormInstallScript,			RemoveScript:  kFormRemoveScript,			};		//if autoClose := newtpkg.autoClose	// !!!g. copy below		//then pkgFrame.autoClose := autoClose;		if devInstallScript		then pkgFrame.devInstallScript := devInstallScript;		if devRemoveScript		then pkgFrame.devRemoveScript := devRemoveScript;		end;	gc();	local defStore :=		if kBuild20 or nos20		then GetDefaultStore()		else call kGetDefaultStoreFunc with ();	:init([], defStore, newtPkg.sizeHint, psym,		pkgType & if partData and newtPkg.dispatchOnly then $!); // !!!a	if icon	// !!!f	then progressOptions.icon := DeepClone(icon);	// !!!g	local flags :=		(if partData and newtPkg.dispatchOnly then 0x8000 else 0) +		(if newtPkg.copyProtected then 0x4000 else 0) +		(if newtPkg.compressed then 0 else 0x1000);	local parts := newtpkg.parts;	// !!!g	foreach sym in kOmitPkgSlots	// !!!a?	do RemoveSlot(newtpkg, sym);	// copy remaining items directly:	//	DoNotInstall, deletionScript, labels, TapAction, iconPro, icon, autoclose	// and any other setPartFrameSlot items//Print(newtpkg); Print(pkgFrame);	foreach sym, val in newtpkg	do pkgFrame.(sym) := val;	newtpkg := NIL;	pkgFrame := { // !!!g		type: 	pkgType,		// required		//flags: 0x00000081,	// optional (default: 0x00000081)		//notification: pkgType,// optional (default: pkgType)		//compressor: nil,		// optional		data: pkgFrame,			// required		};	parts :=		if isArray(parts)		then if kBuild20			then ArrayInsert(Clone(parts), pkgFrame, 0)			else ArrayMunger(Clone(parts),0,0, [pkgFrame],0,nil)		else [pkgFrame];//GetGlobals().pp := self; // ***	if progressView = self	// !!!f	then begin		progressView:SetStatus('vStatus, {titleText: progressOptions.statusText});		Sleep(60);	// leave visible for 1 sec		pkg := :saveInstall(self, defStore, parts, version, copyright, psym, flags);		end	else if kBuild20 or nos20	then DoProgress(progressOptions.type, progressOptions,			func(contextView) pkg := :saveInstall(contextView, defStore, parts, version, copyright, psym, flags))	else begin // 1.x		pkg := :saveInstall(BuildContext(GetLayout("protoProgress")), defStore, parts, version, copyright, psym, flags);		progressView:close();		RefreshViews();		end;	pkgSoup:?removeAllEntries();	if not (if kBuild20 then IsInteger(pkg) else isInstance(pkg,'int))		or (pkg > 0 and pkg<>666)	then PlaySound(ROM_funbeep)	else if HasVariable(self,'error)	then :error('savePackage, {error: pkg})	else GetRoot():Notify(kNotifyAlert,			SPrintObject('savePackage), SPrintObject(pkg));	NIL;	end
       ,
     stuffPackage:
       func(ARRAY parts, INT version, devCopyright, packageName, INT flags) // !!!gbegin	if kProfileOn then EnableProfiling(true);	local INT partOffset := 52, partDataOffset, i;	local part, t;	:setOffset(0,TRUE);// PACKAGE HEADER	StuffCString(segment,  0, if pkgPad=4 then "package1xxxx" else "package0xxxx");	StuffWord	(segment, 12, flags); //uncompressed,copyprotected,dispatchonly ***	StuffWord	(segment, 14, 0);	StuffLong	(segment, 16, version);	StuffWord	(segment, 20, 0);	// offset	StuffWord	(segment, 22, t := (StrLen(devCopyright)+1)*2); // \u	StuffWord	(segment, 24, t); // offset	StuffWord	(segment, 26, (StrLen(packageName) +1)*2); // \u	//StuffLong	(segment, 28, nextChunk); // fill in at end when we know it	//StuffLong	(segment, 32, 0); // create_time, Mac format -- too big	local INT lo, hi; // minutes	lo := (Band(t := Time(),0xFFFF) * 60) + (TimeInSeconds() mod 60);	hi := ((t >> 16) * 60) + (lo >> 16);	StuffWord	(segment, 32, hi);	StuffWord	(segment, 34, lo);	//StuffWord	(segment, 36, hi);	//StuffWord	(segment, 38, lo);	StuffLong	(segment, 36, 0);		StuffLong	(segment, 40, 0);	// write PART HEADERs, including variable length PACKAGE header strings	:stuffPartHeader(partOffset, parts, devCopyright, packageName);	StuffLong	(segment, 44, partDataOffset := nextChunk);	StuffLong	(segment, 48, Length(parts)); // !!!g	for i:=0 to Length(parts)-1	do begin		part := parts[i];		part.offset := nextChunk - partDataOffset;		part.start := nextChunk;		t := part.data;		if StrEqual(part.type, "auto") and not t.InstallScript		then t.InstallScript := kAutoInstallScript;		:stuffChunk(firstChunk := nextChunk, [t]);		part.stop := nextChunk;		end;//Print(parts);	// fixup PACKAGE HEADER with package length	if (nextChunk mod kSegSize) <> 0	then begin		if (segOffset := nextChunk - segBegin) >= segSize			or nextChunk < segBegin		then :setOffset(nextChunk,TRUE);		SetLength (segment, segOffset);		end;	if 0 < segBegin	then :setOffset(0,TRUE);	StuffLong(segment, 28, nextChunk);	// PACKAGE length	// fixup PART HEADER with part length	// partOffset := 52;	for i:=0 to Length(parts)-1	do begin		part := parts[i];		t := part.stop - part.start;		StuffLong(segment, partOffset, 	 part.offset);		StuffLong(segment, partOffset+4, t);		StuffLong(segment, partOffset+8, t);		partOffset := partOffset + kPartHeaderSize;		end;	if segEntry then EntryChange(segEntry);	if kProfileOn	then EnableProfiling(nil);	if kDebugOn	then begin		Print("package length" && nextChunk);		Print([			"pkgAoffs", Length(pkgAoffs),			"pkgOffs", 	Length(pkgOffs),]);		end;end
       ,
     Init:
       func(segs, defStore, sizeHint, psym, pkgType)begin	self.pkgObjs 	:= [nil];	self.pkgOffs 	:= SetClass(Clone(""), '_pkgOffset_);	self.pkgAObjs	:= [];	//self.pkgAOffs	:= NIL; //SetClass(clone(""), '_pkgOffset_);	self.segSize	:= kSegSize; // initially for smallPackage; constant for reg package	self.segments 	:= if isArray(segs) then segs;	self.nextFlush	:= NIL;	// !!!e	self.progressOptions := // DoProgress format.		{closebox: nil,		statusText: kVersion & (if smallPackage then "+S")  & "©S.Weyer\n" & psym,	// !!!c					//"Pkg(" & pkgType & "):" && psym,		titleText: "",		barber: not sizeHint,		gauge: if sizeHint then 0,		maxGauge: sizeHint,		type: if sizeHint then 'vGauge else 'vBarber,		//icon:		};	if kBuild20 or nos20	then begin		local pkg;		self.segBegin := 0;		smallPackage := NIL; // for prog label		if not segments		then pkg := GetPkgRef(segs.title, segs.store);		self.segment := defStore:NewCompressedVBO('packageEntry,	// !!!e			if pkg then (sizeHint := segSize := Length(pkg)) else kSegSize,			kTextCompander, nil);		pkgOffs 	:= defStore:NewCompressedVBO('_pkgOffset_, 0, kTextCompander, nil);	// !!!e		nextFlush	:= kVBOFlush;	// !!!e		if pkg		then :reloFix(BinaryMunger(segment,0,nil,pkg,0,nil),0,[]);		end	else if not smallPackage	then begin		self.pkgSoup := defStore:GetSoup(kPkgSoupName);		if pkgSoup		then pkgSoup:removeAllEntries()		else pkgSoup := defStore:CreateSoup(kPkgSoupName,[]);		self.cursor 	:= Query(pkgSoup,{type: 'index});		if not segments		then segments := BackupPackage(pkgSoup, segs); // test		end;end
       ,
     ArrayDiff:
       func(a1,a2,diff)if length(a1)=length(a2)then begin	local i;	for i:=0 to length(a1)-1	do if a1[i]<>a2[i] and :ObjDiff(a1,a2,i,diff)		then return SetAdd(diff,i,nil);	//NIL;	endelse SetAdd(diff,'len,nil)
       ,
     cursor: nil,
     progressView: nil,
     extractNum: kExtractNum,
     segBegin: -kSegSize,
     segments: nil,
     printPkgEntry:
       func(data,offset, type,len,name,const, hframe)begin	local vlen, val;	if type='int	then val := :extractNum(data, offset, vlen := 2, 0)	else if type='long	then begin		vlen := 4;		val :=			if ExtractByte(data, offset) < 0x40			then ExtractLong(data, offset)			else :printHexBin(data, offset,4,'H);		end	else if type='time	then begin		vlen := 4;		val := ExtractLong(data,offset);		end	else if type='char	then if vlen := len		then val := :extractString(data, offset, len, nil, 1)		else begin			val := ExtractCString(data,offset);			vlen := StrLen(val)+1;			end	else if type='uchar	then if vlen := len		then val := ExtractBytes(data,offset,len,'String)		else begin			val := :extractString(data, offset, len, 'String, 2);			vlen := (StrLen(val)+1)*2;			end;Print([	offset, name, val,	if type='time then DateNTime(val)	else if isInstance(val,'string) then "len="&vlen // IsString(val)	else :printHexBin(val,nil,vlen,'H),	if const	then if (if isInstance(const,'string) // IsString(val)			then StrEqual(const,val) else const=val)		then "OK"		else "*********"	else "",	]);	hframe.(name) := val;	offset+vlen;end
       ,
     pkgAObjs: nil,
     pkgAOffs: nil,
     extractCString2:
       func(offset,len)begin	if (segOffset := offset - segBegin) >= segSize		or offset < segBegin	then :setOffset(offset,NIL);	local dlen := segSize - segOffset;	local s := ExtractCString(segment, segOffset);	if len > dlen	then beginPrint("splitC" && s);		s & :ExtractCString2(offset + dlen, len - dlen);		end	else s;end
     ,
     printPkgEntries:
       func(data,offset, heading, hframe, entries)begin	local elen, type, len, name, const;Print("\n"&heading);	foreach e in entries	do begin		elen := length(e);		type := e[0];		len := if elen >= 3 then e[2];		if isInstance(len,'symbol) // IsSymbol(len)		then len := hframe.(len); // e.g., 'part_sym_len		name := if elen >=2 then e[1];		if not name then name := intern(type&offset);		const := if elen>=4 then e[3];		if isInstance(const,'symbol) // IsSymbol(const)		then const := hframe.(const);		offset := :printPkgEntry(data,offset, e[0],len,name,const, hframe);		end;	offset;end
       ,
     keepValue: kDebugOn,
     shareObj:
       func (obj, int offset) // used only by extractXXXbegin	local cl := Classof(obj);	if cl<>'instructions and cl<>'literals	then begin		AddArraySlot(pkgOffs, offset);		AddArraySlot(pkgObjs, obj);		end;end
       ,
     extractBytes2:
       func(offset,len,dtype)begin	if (segOffset := offset - segBegin) >= segSize		or offset < segBegin	then :setOffset(offset,NIL);	local dlen := segSize - segOffset;	if len <= dlen	then ExtractBytes(segment, segOffset, len, dtype)	else beginPrint("splitB" && dlen);		BinaryMunger(			ExtractBytes(segment, segOffset, dlen, dtype), dlen, 0,			:ExtractBytes2(offset+dlen, len-dlen, dtype), 0, nil);		end;end
     ,
     StuffCString2:
       func NATIVE (INT offset, str, INT start, INT len)begin	if (segOffset := offset - segBegin) >= segSize		or offset < segBegin	then :setOffset(offset,TRUE);	local INT segOff := segOffset;	local INT dlen := segSize - segOff;	if len < 0 then len := if kBuild20 then StrLen(str)+1 else call Functions.StrLen with(str)+1;	local nosplit := len <= dlen;	// StuffCString break near end of data (last xx bytes?)	// plus we don't always want to create substr for str	if start=0 and nosplit and segOff+(len*2) < Length(segment)	then StuffCString(segment,segOff,str)	else begin // slower but reliable fallback		local INT i, null := if nosplit then len-1 else -1; // null index?		for i:=0 to (if nosplit then len else dlen)-1 // len includes null (if null)		do StuffChar(segment, segOff+i,			if i=null then 0 else str[start+i]);		if not nosplit		then :stuffCString2(offset+dlen, str, start+dlen, len-dlen);	end;end
       ,
     pkgSoup: nil,
     BinDiff:
       func(b1,b2,diff)if length(b1)=length(b2)then begin	local i;	for i:=0 to length(b1)-1	do if ExtractByte(b1,i) <> ExtractByte(b2,i)	then return SetAdd(diff,i,nil);	//NIL;	endelse SetAdd(diff,'len,nil)
       ,
     StuffBytes2:
       func NATIVE (INT offset, bytes, INT start, INT len)begin	if (segOffset := offset - segBegin) >= segSize		or offset < segBegin	then :setOffset(offset,TRUE);	local INT dlen := segSize - segOffset;	if len<0 then len := Length(bytes);	if len <= dlen	then BinaryMunger(segment,segOffset,len, bytes,start,len)	else begin		BinaryMunger(segment,segOffset,dlen, bytes,start,dlen);		:stuffBytes2(offset+dlen, bytes, start+dlen, len-dlen);		end;end
     ,
     viewClass: 74 /* clView */,
     extractVPUM:
       func(offset)begin	if (segOffset := offset - segBegin) >= segSize		or offset < segBegin	then :setOffset(offset,NIL);	local kREF := Functions.REF; // avoid compiler warnings	local byte3 := ExtractByte(segment, segOffset+3);	local bits2 := Band(byte3, 0x3);	if bits2=0				// VALUE	then if ExtractByte(segment,segOffset) < 0x20		then call kREF with(ExtractLong(segment,segOffset))		else :extractNum(segment,segOffset,4,-2)	else begin		local longVal := ExtractLong(segment,segOffset);		if bits2=1			// POINTER to Data, Array or Frame		then :extractChunk(longVal-1)		else if bits2=3			// MAGIC POINTER ??? Ref?		then call kREF with(longVal)		else if byte3=0x52 and	// UNUSUAL/UNICODE			longVal=0x00055552		// SYMBOL		then kSymbolType		else call kREF with (longVal);	// NIL, TRUE, WEAK ARRAY, UNICODE CHAR		end;end
       ,
     testpackage:
       func(ptitle,asym, doit, keepValue, extract)//{_parent: tt, _proto: tt.protoPackage}:testPackage("ProtNOS2:TKnollSys",nil, true, nil, true)begin	local ARRAY pkgs := GetPackages();	local ppos, pkg :=		if kBuild1x and Functions.ArrayPos exists		then begin			if ppos := ArrayPos(pkgs,ptitle,0,func(pt,p) StrEqual(pt,p.title))			then pkgs[ppos];			end		else LFetch(pkgs,ptitle,0,'|str=|,'title);/*	local epos := ArrayPos(Extras,asym,0,			if isInstance(asym,'symbol)			then func(a,e) a=e.app			else func(a,e) e.app='copperfield and StrEqual(a,e.isbn)			);	local exApp := if epos then Extras[epos];	if not (doit and pkg and exApp)	then return Print([pkg, exApp]);*/	:init(pkg, if kBuild20 then GetDefaultStore() else call kGetDefaultStoreFunc with(),nil,ptitle,"?"); // ???	pkgOffs := [0];	if not extract	then return self;	local pkgFrame := :extractPackage(nil);	progress:?close();/*	if keepValue	then begin		Print(:ObjDiff(pkgFrame.part1[0], exApp, '[pathExpr: icon, bits], []));		Print(:ObjDiff(pkgFrame.part1[0], exApp, '[pathExpr: theForm], []));		end;*/	pkgSoup:?removeAllEntries();	pkgFrame;end
       ,
     reloFix:
       func native (pkg, INT offset, ARRAY relo)begin	local INT obj;	if offset=0	then begin		// first time. find first object & relo		// assume this is an array with 1 element		offset := ExtractWord(pkg, 46); 		// skip header,0,type(+12)		// [0] should point to next object (+4) in pkg		// keep relo in array of 4 bytes -- "long" is too big; (words messy)		obj := offset+16+1;		relo := [			ExtractByte(pkg,offset+12),			ExtractByte(pkg,offset+13),			ExtractByte(pkg,offset+14) - (obj div 256),			ExtractByte(pkg,offset+15) - (obj mod 256),			];		Print("relo:"); Print(relo);		end;	local INT ctype := ExtractByte(pkg,offset+3); // DATA (0x40), ARRAY (0x41), FRAME (0x43)	local INT clen  :=		if ctype = 0x40 // DATA		then 12 // only check type		else 	ExtractByte(pkg,offset)*65536 +				ExtractByte(pkg,offset+1)*256 +				ExtractByte(pkg,offset+2);	local INT i, p;	for i := offset+8 to offset+clen-4 by 4	do if ExtractByte(pkg,i)<>0 and // not already relocated? (assumes pkg < 17M)			BAND(ExtractByte(pkg, i+3), 0x3) = 1 // obj ptr?		then begin			obj := 0;			for p := 0 to 3			do obj := obj*256 + (ExtractByte(pkg,i+p) - relo[p]);			//Print(i & ": " & obj);			StuffLong(pkg, i, obj);			obj := obj-1; 		// make ptr an offset			if obj > offset	// needs fixing only if later in package?			then :reloFix(pkg, obj, relo);			end;	pkg;end
       ,
     saveInstall:
       func(contextView, defStore, ARRAY parts, INT version, copyright, psym, INT flags)	// !!!fbegin	local pkg;	progressView := contextView;	try begin		:stuffPackage(parts, // !!!g			version,			copyright,			SPrintObject(psym),			flags			);		progressOptions.titleText := "InstallingÉ" & unicodeCR & nextChunk;		progressOptions.barber := nil;		progressOptions.gauge := 0;		progressView:SetStatus(progressOptions.type := 'vGauge, progressOptions);//Print(segment);		//if kDebugOn then :extractPackage(true);		pkg := if kBuild20 or nos20			then defStore:suckPackageFromBinary(segment,				{callbackFreq: 2048,	// callbackFrequency wrong in docs!				callBack: func(callbackInfo)					begin//Print(callbackInfo);					progressOptions.gauge := RIntToL(callbackInfo.amountRead / callbackInfo.packageSize * 100);					progressView:SetStatus(progressOptions.type, progressOptions);					end,					})			else if pkgSoup			then defStore:RestoreSegmentedPackage(pkgSoup, segments)			else defStore:RestorePackage(segment); // "small" package (pre 1.3 ROMs) or VBO (2.x)		end		onexception |evt.ex|		do begin	// 666 if Stop button			pkg := currentException();			pkg := if pkg.error				then pkg.error				else if pkg.data.errorCode exists				then pkg.data.errorCode				else -1;			end;	pkg;end
       ,
     stuffVPUM:
       func (INT offset, val)begin	local sval :=		if isImmediate(val) and		// isInstance breaks if array class is a number			(if kBuild20 then IsInteger(val) else isInstance(val,'int)) and			(val > 0x07FFFFFF or // 134217727	 		val < 0x38000000)		then NIL // write as "big" INT (RefOf inaccurate)		else if val=kSymbolType 	// my special symbol flag		then 0x00055552		else if isImmediate(val) // IMMEDIATE: "small" INT, NIL, TRUE, WEAK ARRAY, UNICODE CHAR			or IsMagicPtr(val)  // MAGIC POINTER		then begin			sval := if kBuild20 then RefOf(val) else call Functions.RefOf with (val); // val << 2, (val << 2) + 3 ???if IsMagicPtr(val) then Print("magic:" && sval);			sval;			end		else // POINTER: FRAME, ARRAY, SYMBOL, BINARY			:stuffChunk(nextChunk,val)+1;	if (segOffset := offset - segBegin) >= segSize		or offset < segBegin	then :setOffset(offset,TRUE);	if sval	then StuffLong(segment, segOffset, sval)	else call kStuffNum with (segment, segOffset, val, 4, -2);end
       
    };

// After Script for protoPackage
thisView := protoPackage;
begin		RemoveSlot(thisView,'ObjDiff);		RemoveSlot(thisView,'FrameDiff);		RemoveSlot(thisView,'BinDiff);		RemoveSlot(thisView,'ArrayDiff);	if not kDebugOn	then begin		RemoveSlot(thisView,'testPackage);		RemoveSlot(thisView,'shareObj);		RemoveSlot(thisView,'reloFix);		RemoveSlot(thisView,'keepValue);		RemoveSlot(thisView,'extractBytes2);		RemoveSlot(thisView,'extractChunk);		RemoveSlot(thisView,'extractCString2);		RemoveSlot(thisView,'extractNum);		RemoveSlot(thisView,'extractPackage);		RemoveSlot(thisView,'extractString);		RemoveSlot(thisView,'extractVPUM);		RemoveSlot(thisView,'printHexBin);		RemoveSlot(thisView,'printPkgEntries);		RemoveSlot(thisView,'printPkgEntry);		end;	partData.(kPartDataSymbol) := thisView; // !!!aend



constant |layout_protoPackage| := protoPackage;
// End of file protoPackage



