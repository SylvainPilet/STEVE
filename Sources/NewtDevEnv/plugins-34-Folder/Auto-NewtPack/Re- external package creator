To: Rudy Moore <orn@cs.wisc.edu>From: weyer@netaxs.com (Steve Weyer)Subject: Re: external package creatorCc: Bcc: X-Attachments: hi Rudy,>>users who wanted to save their formulas as packages could register with me for only NewtPack for $10. if they later decided to register for NewtDevEnv or for Newt's Cape, I might apply that to the price. >this sounds fine. I think people will like the idea of the NewtPack functionality being applicable to a bunch of different applications. >>if that sounds reasonable, tell me a little more about how you're structuring your stuff. is it an autopart that installs child templates, or an application? does it have methods that you've compiled or just slots & values. a print of a sample frame would be useful. I can then provide you with some API & context info (and maybe some cleanup hints) so that things will save properly with NewtPack. >Currently, I build the formula up on the fly. As the user enters their data, I create a slot in fomulaList that contains their data. I proto off a few (undocumented) system protos. I was planning on dumping out a chunk of text that would include the installScript and removeScript necessary to turn this functionality into an autopart. So, in short, it just builds up templates in the formulaList for their function. These contain both methods and simple slots with data. I had done something like this in a formulas example that I gave to Newt users. here' the installScript and removeScript I had used (based on array of formulaTemplates): installScript :=func(partFrame,removeFrame) beginlocal formulaTemplates := partFrame.partData.formulaTemplates; if length(formulaList)+length(formulaTemplates) <= 16 then beginformulaTemplates := clone(formulaTemplates);	// array itself (not items) internalformulaTemplates[0] := clone(formulaTemplates[0]);	// 1st item (top-level frame) is internal for later ArrayPosremoveFrame.(EnsureInternal('formulaTemplates)) := formulaTemplates; // save for removeScript ArrayMunger(FormulaList,length(FormulaList),0,	// add new panels to endformulaTemplates,0,nil);//if Formulas is open - force update to show our entry // (Newt note: this is the way NTK defined in preefmad; // ViewIsOpen is much cleaner but unfortunately, bigger // since it would have to defined as a platform function) if GetRoot().formulaRoll.viewCObjectthen GetRoot().formulaRoll:RedoChildren(); endelse GetRoot():Notify(3,	// kNotifyAlert=3EnsureInternal("FormulaAdd"),EnsureInternal("too many formulas"));endremoveScript:=func(removeFrame)beginlocal formulaTemplates := removeFrame.formulaTemplates, pos; if formulaTemplates and (pos := ArrayPos(FormulaList,formulaTemplates[0],0,nil)) then beginArrayRemoveCount(FormulaList, pos, length(formulaTemplates)); //if Formulas is open - force update to remove our entry if GetRoot().formulaRoll.viewCObjectthen GetRoot().formulaRoll:RedoChildren(); end;end>BTW, I plan on replacing the undocumented system proto that I currently use with a proto that I'll write that behaves the same - for compatibility reasons... One ugliness that this leads to is the repetition of these protos in all the formula autoparts that a user installs. safest to be self-contained. but it might be possible to have an option where if the user chose not to save the protos, it would expect the formula building app to be installed so it could use that (as a runtime). >I can come up with a sample frame later this evening if that would clarify my explanation. One thing that this doesn't explain, for example, is that I also store their formula in a soup - this allows you two remove and reinstall the app without destroying all the formulas you wrote. Do you think it's possible to install the formula directly from the soup? This would help cut down on the amount of heapspace the application uses.That should be quite possible. I used to do something like this with my old RUNewt module (I stored applications as frames in a soup, then reconstructed them to run). NewtPack is set up to copy objects from soups. You can build a frame where that contains references to a function & id; when NewtPack encounters this, it runs the function in order to obtain the actual object to save. This allows very large packages to be created without needing everything in heap. (For example, Newt's Cape uses this to create large books by stashing paragraphs and graphics in a soup). So, basically you'd hand NewtPack a frame that either contained the formulas directly or a datastructure (like a deferredCall) that could obtain it. >Finally, in an unrelated aside, could you explain to me how to "dereference" a symbol? I'd like to get and manipulate the symbol name in a frame using a construction like:>foreach var in frameName do print(symbolName(var)) with a result that prints all the symbolNames in a particular frame. foreach allows you to specify both path and variable, so foreach sym,var in frameName do print(sym);