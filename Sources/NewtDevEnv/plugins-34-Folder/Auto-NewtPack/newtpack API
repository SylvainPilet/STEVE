/*NewtPack APIS. Weyer27 May 97 -- notes about method cleanup; entryAliases, deferredPackageObjects20 Nov 96 -- updated for NOS 2.x. assumes NewtPack 3.3 (or greater) 2 Apr 97 -- 1.x substitutions noted; notes on 2.x packages Information about NewtPack API.This describes how to save apps and autoparts as packages using NewtPack.Books are supported but currently not documented here;other types (store,font) and multi-part packages currently not supported.This information is NOT PUBLIC and is to be used onlyby authorized developers who discuss with me how NewtPackwill be used, registered/licensed, and distributed.Below are suggested implementations for- saveApp (the main method)- savePackageConfirm (for handling the situation of existing package  and last minute cleanup).(You can use different names).Both NewtDevEnv and Newt's Cape use similar methods. */constant kNewtSymbol := '|NewtDevEnv:TKnollSys|;curPkg: nil,saveApp: func(app) // app is the frame to save. documented at endif GetGlobals().(kNewtSymbol).protos.protoPackage exists // NewtPack installed?then begin	local asym := app.appSymbol;	self.curPkg :=		{_parent: self,		_proto: GetGlobals().(kNewtSymbol).protos.protoPackage,       	appTemplate: app,	// the app frame. see docs at end.       	existingPackage: LFetch(	// 1.x: use for loop       		GetPackages(), SPrintObject(asym), 0, '|str=|, 'title),        	};	if curPkg.existingPackage	then AsyncConfirm(	// 1.x: use :Confirm		"Replace" && asym && $?, 'yesNo,		func(x) self:savePackageConfirm(x)) 	else :savePackageConfirm(true);	endelse :Notify(kNotifyAlert, title, EnsureInternal("NewtPack not installed"))savePackageConfirm: func(fl)if flthen begin	local pkg := curPkg;	curPkg := NIL; // just keep local reference	if pkg.existingPackage    then SafeRemovePackage(pkg.existingPackage); // 1.x: RemovePackage	// your last chance to remove any lingering references to your app object	// only ref should be via pkg.appTemplate -- it will be destructively modified.	pkg:savePackage(); // invoke NewtPack	endelse curPkg := NIL;// -----// structure of the frame passed to saveApp (appTemplate){appSymbol: <symbol>,		// unique package symboltitle: <string>,			// optional (used for default shortTitle)...							// other slots if this is an application							// if this is an autopart, see partData_package: {	pkgSymbol: <symbol>,	// unique package symbol. (default: appSymbol)	version: <integer>,		// optional (default: 1)	partData: <frame>,  	// if nil, this is an app. if a frame, this is an AUTOPART	copyright: <string>,	// optional. default: © 1997. & GetUserConfig('name)	installScript: <method>,// optional for app. required for AUTOPART	removeScript: <method),	// optional for app. required for AUTOPART	shortTitle: <string>,	// optional (Extras title). (default: title; otherwise pkgSymbol)	icon: <bitmap frame>,	// optional for app. unused for AUTOPART	autoClose: <boolean>,	// optional. package won't close automatically. default: nil.	copyProtected:<boolean>,// optional. package can't be beamed, backed up. default: nil.	compressed: <boolean>,	// optional. package stored compressed. default: nil. 	dispatchOnly: <boolean>,// optional. dispatch-only autopart. default: nil.	sizeHint: <integer>,	// optional. max value for progress gauge (2.x default: barber used instead)	// NOS 2.x only	labels: <symbol>,		// optional (Extras folder). default: nil (Unfiled)	deletionScript:<method>,// optional (pkg deleted vs just removed, e.g., card removed)	DoNotInstall: <method>,	// optional. returns boolean (NIL to install)	iconPro: <gray icon>,	// optional. a gray icon for 2.1 systems	TapAction: func() ...,	// optional. for autopart "about". requires text:	text: <string>,			// required for TapAction	<anything else>			// NewtPack will store in packageframe (like SetPartFrameSlot)	},}// -----/*additional notes:for an application, the app frame would correspond to the template (view._proto)Any methods included in the app frame must not contain any referencesto your development environment.  For example, if you compiled these methodslocally on the Newton, the argframe may contain references to objects that youdo not need to save (and if you do, your package will be unnecessarily larger,and you may run out of memory or heap when it copies your app, Root,...).For any method (meth) after you compile, you should apply the following fix(for both 1.x and 2.x):	local fr, meth;	...	if isInstance(meth,'_function) or isInstance(meth,'CodeBlock)	then begin		if (fr := meth.argFrame)		then fr._nextArgFrame := fr._Parent := fr._implementor := NIL;		end;You may need to check frames or arrays for methods.You should also be careful that any slots you include in the app frame (orin partData) do not include references to views or GetRoot.  (It's ok toinclude these in the _package frame since it is not saved -- only the slotsabove are copied).NewtPack 3.3-2 creates a 2.x only package (slightly denser)Use of other -2 plugins, e.g., PlatFnc2, can make a package 2.x only.Not zeroing CompilerCompatibility when compiling on a 2.x Newton can also make a package 2.x only.Otherwise, a package will be compatible with all Newtons*//* note about using "virtual objects" to minimize heap space for large frames to be savedthree kinds of virtual objects can be used:- virtual binary objects (strings, data) -- copied and turned into regular (non-virtual, package) objects------ 2.x: entry aliases.  if NewtPack encounters an entry alias, it will use thedata: slot as the object instead. if there are appSymbol: and appMsg: slots,NewtPack will send a message to obtain the new object -- it does:val := ResolveEntryAlias(alias);obj := if val.appSymbol       	then Perform(GetRoot().(val.appSymbol), val.appMsg, [val.data])       	else val.data;you would create these (generally replacing "theValue" in your structure with its alias)theValue := MakeEntryAlias(GetUnionSoupAlways("yourtemporarysoup"):AddFlushedXmit(	{appSymbol: kAppSymbol, appMsg: 'someMsg, data: theValue}, nil)					this assumes that you want to transform/fixup the stored value (via someMsg)before save occurs.otherwise, the following is direct/simple:theValue := MakeEntryAlias(GetUnionSoupAlways("yourtemporarysoup"):AddFlushedXmit({data: theValue}, nil)You can use an identical entry alias several places in the frame andNewtPack correctly saves just a single reference to the underlying valueand removes the soup entry (after saving it the first time). If you hadtwo different (<>) aliases to the same entry, NewtPack would create a copy-- if this is what you really intend, just create two different entries (withdifferent aliases).------ "deferred package objects". similar to entry aliases for 1.x(should work also for 2.x, but entry aliases recommended).if NewtPack encounters a deferredPackageObject, it calls a functionwith an entry id to obtain the stored value.a deferredPackageObject is an array of class (deferredPackageObject) with two elements:- a function- a single arg (or an array of arguments)e.g.,   [deferredPackageObject: myFn, val]or [deferredPackageObject: myFn, args]Apply(myFn, [val]) //Apply(myFn, args)to create a deferredPackageObject, save data to a soup using your own id# or the _uniqueID.theEntry := mytemporarysoup:add({contentID: myId, data: theValue})theValue := [deferredPackageObject: myFn, myId]ortheValue := [deferredPackageObject: myFn, [myId, other args]]ortheValue := [deferredPackageObject: myFn, EntryUniqueId(theEntry)]myFn is responsible for removing temporary entries after they are accessed*/