NewtPack     savePackage:       func(fl)       if fl       then begin       	local newtPkg := appTemplate._package;       	local asym := appTemplate.appSymbol;       	/* if newtPkg.existingPackage       	then :?RemovePackage(asym);       	:?removeApp(newtPkg.newtSymbol);	// since this is destructive       	*/       	RemoveSlot(appTemplate,'_package); // don't save this       	...       	else kCopyright && call kGetUserConfigFunc with('name),...       	if isinstance(pkg,'int) and pkg<0       	then GetRoot():Notify(3, EnsureInternal("savePackage"), SPrintObject(pkg))       	else PlaySound(ROM_funbeep); //if not partData then :addView(asym);Newt     curPkg: nil,     saveApp:       func(asym)       //if isArray(asym)       //then call PerformVals with(self,'saveApp,asym)       //else       begin       	local appView :=       		if isInstance(asym,'symbol) //IsSymbol(asym)       		then GetSlot(newtView,asym)       		else asym;       	if isFrame(appView)       	then if protoPackage exists       		then begin       			local appTemplate := if appView.isbn then appView.book else appView._proto;       			curPkg := {       				//_parent: self, // ???       				_proto: protoPackage,       				protoProgress: protoProgress,       				appTemplate: appTemplate,       				smallPackage: prefsCurrent.smallPackage or not HasVariable(Functions,'RestoreSegmentedPackage), // ***       				};       			if appTemplate._package.existingPackage and prefsCurrent.doConfirm       			then GetRoot():Confirm(title, kReplacePackage && appTemplate.appSymbol,       					self, 'savePackageConfirm)				else :savePackageConfirm(true);savePackageConfirm: func(fl)if flthen begin	local pkg := curPkg, appTemplate := pkg.appTemplate;	curPkg := nil;	if appTemplate._package.existingPackage	then :RemovePackage(appTemplate.appSymbol)	:removeApp(appTemplate._package.newtSymbol);	pkg:savePackage();	endelse curPkg := nil-----Newt's Cape     curPkg: nil,     saveBook:       func()       if curBook and NewtPack and Length(curBook.contents) > 0       then begin       	// use NewtPack directly -- if it's installed       	local gDataProtos := GetGlobals().(kNewtSymbol).protos, isbn := curBook.isbn;       	if not curBook.appSymbol       	then curBook.appSymbol := Intern(isbn);              	curPkg := {       		//_parent: self, // inheritance of error, removeApp, GetUserConfig       		_proto: gDataProtos.protoPackage,       		protoProgress: gDataProtos.protoProgress,       		appTemplate: curBook,       		smallPackage: not Functions.RestoreSegmentedPackage,       		};              	if not libook // current book never opened       		and (exbook or (exbook := call kFindBook with (isbn,nil)))       	then begin       		curBook._package.existingPackage := true;       		GetRoot():Confirm(title,       			kReplacePkg && exbook.appSymbol & "\nisbn:" && isbn & "?",       			self, 'savePackageConfirm);       		end       	else :savePackageConfirm(true);       	end,savePackageConfirm: func(fl)if flthen begin	local pkg := curPkg, appTemplate := pkg.appTemplate;	exbook := curPkg := nil;	if appTemplate._package.existingPackage	then :RemovePackage(appTemplate.appSymbol)	:removeApp(curBook.isbn);	pkg:savePackage();	endelse curPkg := nilx GetUserConfig:     bookTemplate:       func()       begin       local user := clone(call kGetUserConfigFunc with('name));...       	base_href: NIL,		// URL for BASE (used in kGotoHREF)       	GetUserConfig: kGetUserConfigFunc,       	},x error:errorStop >> error connect:       	if epErr       	then SetValue(statusPara, 'text, "Instantiate Err" && epErr)       	else if epErr := ep:Connect(raddress, nil)       	then SetValue(statusPara, 'text, "Connect Err" && epErr)